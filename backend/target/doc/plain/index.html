<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A small Rust library that allows users to interpret arrays of bytes as certain kinds of structures safely."><title>plain - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-84e720fa.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="plain" data-themes="" data-resource-suffix="" data-rustdoc-version="1.89.0 (29483883e 2025-08-04)" data-channel="1.89.0" data-search-js="search-92309212.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-4e99c027.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-fd3af306.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../plain/index.html">plain</a><span class="version">0.2.3</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#purpose" title="Purpose">Purpose</a></li><li><a href="#examples" title="Examples">Examples</a></li><li><a href="#comparison-to-pod" title="Comparison to `pod`">Comparison to <code>pod</code></a></li></ul><h3><a href="#enums">Crate Items</a></h3><ul class="block"><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>plain</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/plain/lib.rs.html#1-158">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A small Rust library that allows users to interpret arrays of bytes
as certain kinds of structures safely.</p>
<p>This crate provides an unsafe trait <a href="trait.Plain.html"><code>Plain</code></a>, which the user
of the crate uses to mark types for which operations of this library are safe.
See <a href="trait.Plain.html"><code>Plain</code></a> for the contractual obligation.</p>
<p>Other than that, everything else in this crate is perfectly safe to use as long
as the <code>Plain</code> trait is not implemented on inadmissible types (similar to how
<code>Send</code> and <code>Sync</code> in the standard library work).</p>
<h2 id="purpose"><a class="doc-anchor" href="#purpose">§</a>Purpose</h2>
<p>In low level systems development, it is sometimes necessary to
interpret locations in memory as data structures. Functions of
this crate serve to avoid pitfalls associated with that, without
having to resort to big, full-featured (de)serialization libraries.</p>
<p>On the other hand, this crate contains no provisions when it comes
to handling differences in encoding and byte ordering between
platforms. As such, it is entirely unsuitable for processing
external data such as file contents or network packets.</p>
<h2 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h2>
<p>To start using the crate, simply do <code>extern crate plain;</code>.</p>
<p>If you want your plain types to have methods from this crate, also include <code>use plain.Plain;</code>.</p>
<p>Then it’s just a matter of marking the right types and using them.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">extern crate </span>plain;
<span class="kw">use </span>plain::Plain;
<span class="kw">use </span>std::mem;


<span class="attr">#[repr(C)]
#[derive(Default)]
</span><span class="kw">struct </span>ELF64Header {
    <span class="kw">pub </span>e_ident: [u8; <span class="number">16</span>],
    <span class="kw">pub </span>e_type: u16,
    <span class="kw">pub </span>e_machine: u16,
    <span class="kw">pub </span>e_version: u32,
    <span class="kw">pub </span>e_entry: u64,
    <span class="kw">pub </span>e_phoff: u64,
    <span class="kw">pub </span>e_shoff: u64,
    <span class="kw">pub </span>e_flags: u32,
    <span class="kw">pub </span>e_ehsize: u16,
    <span class="kw">pub </span>e_phentsize: u16,
    <span class="kw">pub </span>e_phnum: u16,
    <span class="kw">pub </span>e_shentsize: u16,
    <span class="kw">pub </span>e_shnum: u16,
    <span class="kw">pub </span>e_shstrndx: u16,
}

<span class="comment">// SAFE: ELF64Header satisfies all the requirements of `Plain`.
</span><span class="kw">unsafe impl </span>Plain <span class="kw">for </span>ELF64Header {}

<span class="kw">impl </span>ELF64Header {
	<span class="kw">fn </span>from_bytes(buf: <span class="kw-2">&amp;</span>[u8]) -&gt; <span class="kw-2">&amp;</span>ELF64Header {
		plain::from_bytes(buf).expect(<span class="string">"The buffer is either too short or not aligned!"</span>)
	}

	<span class="kw">fn </span>from_mut_bytes(buf: <span class="kw-2">&amp;mut </span>[u8]) -&gt; <span class="kw-2">&amp;mut </span>ELF64Header {
		plain::from_mut_bytes(buf).expect(<span class="string">"The buffer is either too short or not aligned!"</span>)
	}

	<span class="kw">fn </span>copy_from_bytes(buf: <span class="kw-2">&amp;</span>[u8]) -&gt; ELF64Header {
		<span class="kw">let </span><span class="kw-2">mut </span>h = ELF64Header::default();
		h.copy_from_bytes(buf).expect(<span class="string">"The buffer is too short!"</span>);
		h
	}
}


<span class="comment">// Conditional copying for ultimate hackery.
</span><span class="kw">fn </span>opportunistic_elf_processing(buf: <span class="kw-2">&amp;</span>[u8]) {
	<span class="kw">if </span>plain::is_aligned::&lt;ELF64Header&gt;(buf) {
        <span class="comment">// No copy necessary.
		</span><span class="kw">let </span>elf_ref = ELF64Header::from_bytes(buf);
		process_elf(elf_ref);
    } <span class="kw">else </span>{
        <span class="comment">// Not aligned properly, copy to stack first.
		</span><span class="kw">let </span>elf = ELF64Header::copy_from_bytes(buf);
		process_elf(<span class="kw-2">&amp;</span>elf);
    }
}

<span class="attr">#[repr(C)]
#[derive(Default, Copy, Clone)]
</span><span class="kw">struct </span>ArrayEntry {
    <span class="kw">pub </span>name: [u8; <span class="number">32</span>],
    <span class="kw">pub </span>tag: u32,
    <span class="kw">pub </span>score: u32,
}

<span class="comment">// SAFE: ArrayEntry satisfies all the requirements of `Plain`.
</span><span class="kw">unsafe impl </span>Plain <span class="kw">for </span>ArrayEntry {}

<span class="kw">fn </span>array_from_bytes(buf: <span class="kw-2">&amp;</span>[u8]) -&gt; <span class="kw-2">&amp;</span>[ArrayEntry] {
    <span class="comment">// NOTE: length is not a concern here,
    // since slice_from_bytes() can return empty slice.

    </span><span class="kw">match </span>plain::slice_from_bytes(buf) {
        <span class="prelude-val">Err</span>(<span class="kw">_</span>) =&gt; <span class="macro">panic!</span>(<span class="string">"The buffer is not aligned!"</span>),
        <span class="prelude-val">Ok</span>(arr) =&gt; arr,
    }
}

<span class="kw">fn </span>array_from_unaligned_bytes(buf: <span class="kw-2">&amp;</span>[u8]) -&gt; Vec&lt;ArrayEntry&gt; {
	<span class="kw">let </span>length = buf.len() / mem::size_of::&lt;ArrayEntry&gt;();
	<span class="kw">let </span><span class="kw-2">mut </span>result = <span class="macro">vec!</span>[ArrayEntry::default(); length];
 	(<span class="kw-2">&amp;mut </span>result).copy_from_bytes(buf).expect(<span class="string">"Cannot fail here."</span>);
	result
}

</code></pre></div>
<h2 id="comparison-to-pod"><a class="doc-anchor" href="#comparison-to-pod">§</a>Comparison to <a href="https://crates.io/crates/pod"><code>pod</code></a></h2>
<p><a href="https://crates.io/crates/pod"><code>pod</code></a> is another crate created to help working with plain data.
The major difference between <code>pod</code> and <code>plain</code> is scope.</p>
<p><code>plain</code> currently provides only a few functions (+method wrappers) and its implementation
involves very few lines of unsafe code. It can be used in <code>no_std</code> code. Also, it doesn’t
deal with <a href="https://en.wikipedia.org/wiki/Endianness">endianness</a> in any way,
so it is only suitable for certain kinds of low-level work.</p>
<p><code>pod</code>, on the other hand, provides a wide arsenal
of various methods, most of which may be unnecessary for a given use case.
It has dependencies on <code>std</code> as well as other crates, but among other things
it provides tools to handle endianness properly.</p>
<p>In short, <code>plain</code> is much, much <em>plainer</em>…</p>
</div></details><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.Error.html" title="enum plain::Error">Error</a></dt></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.Plain.html" title="trait plain::Plain">Plain</a></dt><dd>A trait for plain data types that can be safely read from a byte slice.</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.as_bytes.html" title="fn plain::as_bytes">as_<wbr>bytes</a><sup title="unsafe function">⚠</sup></dt><dd>Interpret data as bytes. Not safe for data with padding.</dd><dt><a class="fn" href="fn.as_mut_bytes.html" title="fn plain::as_mut_bytes">as_<wbr>mut_<wbr>bytes</a><sup title="unsafe function">⚠</sup></dt><dd>Interpret data as mutable bytes.
Reading is not safe for data with padding. Writing is ok.</dd><dt><a class="fn" href="fn.copy_from_bytes.html" title="fn plain::copy_from_bytes">copy_<wbr>from_<wbr>bytes</a></dt><dd>Copies data from a byte slice into existing memory.
Suitable when <a href="fn.from_bytes.html"><code>from_bytes()</code></a> would normally
be used, but the data is not aligned properly in memory.</dd><dt><a class="fn" href="fn.from_bytes.html" title="fn plain::from_bytes">from_<wbr>bytes</a></dt><dd>Safely converts a byte slice to a reference.</dd><dt><a class="fn" href="fn.from_mut_bytes.html" title="fn plain::from_mut_bytes">from_<wbr>mut_<wbr>bytes</a></dt><dd>See <a href="fn.from_bytes.html"><code>from_bytes()</code></a>.</dd><dt><a class="fn" href="fn.is_aligned.html" title="fn plain::is_aligned">is_<wbr>aligned</a></dt><dd>Check if a byte slice is aligned suitably for type T.</dd><dt><a class="fn" href="fn.slice_from_bytes.html" title="fn plain::slice_from_bytes">slice_<wbr>from_<wbr>bytes</a></dt><dd>Similar to <a href="fn.from_bytes.html"><code>from_bytes()</code></a>,
except that the output is a slice of T, instead
of a reference to a single T. All concerns about
alignment also apply here, but size is handled
differently.</dd><dt><a class="fn" href="fn.slice_from_bytes_len.html" title="fn plain::slice_from_bytes_len">slice_<wbr>from_<wbr>bytes_<wbr>len</a></dt><dd>Same as <a href="fn.slice_from_bytes.html"><code>slice_from_bytes()</code></a>,
except that it takes explicit length of the result slice.</dd><dt><a class="fn" href="fn.slice_from_mut_bytes.html" title="fn plain::slice_from_mut_bytes">slice_<wbr>from_<wbr>mut_<wbr>bytes</a></dt><dd>See <a href="fn.slice_from_bytes.html"><code>slice_from_bytes()</code></a>.</dd><dt><a class="fn" href="fn.slice_from_mut_bytes_len.html" title="fn plain::slice_from_mut_bytes_len">slice_<wbr>from_<wbr>mut_<wbr>bytes_<wbr>len</a></dt><dd>See <a href="fn.slice_from_bytes_len.html"><code>slice_from_bytes_len()</code></a>.</dd></dl></section></div></main></body></html>