searchState.loadedDescShard("im", 0, "Immutable Data Structures for Rust\nAn unordered map.\nAn unordered set.\nAn ordered map.\nAn ordered set.\nA persistent vector.\nConcatenate two vectors.\nConcatenate two vectors.\nUpdate the value for a given key by calling a function with\nUpdate the value for a given key by calling a function with\nDiscard all elements from the map.\nDiscard all elements from the set.\nDiscard all elements from the map.\nDiscard all elements from the set.\nClone a map.\nClone a set.\nClone a map.\nClone a set.\nClone a vector.\nTest if a value is part of a set.\nTest if a value is part of a set.\nTest for the presence of a key in a map.\nTest for the presence of a key in a hash map.\nGet an iterator over the differences between this map and …\nGet an iterator over the differences between this set and …\nConstruct the symmetric difference between two maps by …\nConstruct the symmetric difference between two sets.\nConstruct the symmetric difference between two maps by …\nConstruct the symmetric difference between two sets.\nConstruct the symmetric difference between two maps by …\nConstruct the symmetric difference between two maps by …\nConstruct the symmetric difference between two maps by …\nConstruct the symmetric difference between two maps by …\nGet the <code>Entry</code> for a key in the map for in-place …\nGet the <code>Entry</code> for a key in the map for in-place …\nAdd values to the end of a vector by consuming an iterator.\nRemove a key/value pair from a map, if it exists, and …\nRemove a key/value pair from a map, if it exists, and …\nRemove a key/value pair from a map, if it exists, and …\nRemove a key/value pair from a map, if it exists, and …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a vector from a <code>std::vec::Vec</code>.\nCreate a vector from a <code>std::vec::Vec</code>.\nReturns the argument unchanged.\nCreate a vector from an iterator.\nGet the value for a key from a map.\nGet the value for a key from a hash map.\nGet a value inside multiple levels of data structures.\nGet the key/value pair for a key from a map.\nGet the key/value pair for a key from a hash map.\nGet the largest key in a map, along with its value. If the …\nGet the largest value in a set.\nGet the smallest key in a map, along with its value. If the\nGet the smallest value in a set.\nGet a mutable reference to the value for a key from a map.\nGet a mutable reference to the value for a key from a hash …\nGet the closest larger entry in a map to a given key as a …\nGet the closest larger value in a set to a given value.\nGet the closest larger entry in a map to a given key as a …\nGet the closest smaller entry in a map to a given key as a …\nGet the closest smaller value in a set to a given value.\nGet the closest smaller entry in a map to a given key as a …\nGet a reference to the map’s <code>BuildHasher</code>.\nGet a reference to the set’s <code>BuildHasher</code>.\nAn unordered map.\nConstruct a hash map from a sequence of key/value pairs.\nAn unordered set.\nConstruct a set from a sequence of values.\nGet a reference to the value at index <code>index</code> in the vector.\nGet a mutable reference to the value at index <code>index</code> in the …\nInsert a key/value mapping into a map.\nInsert a value into a set.\nInsert a key/value mapping into a map.\nInsert a value into a set.\nConstruct the intersection of two maps, keeping the values …\nConstruct the intersection of two sets.\nConstruct the intersection of two maps, keeping the values …\nConstruct the intersection of two sets.\nConstruct the intersection of two maps, calling a function …\nConstruct the intersection of two maps, calling a function …\nConstruct the intersection of two maps, calling a function …\nConstruct the intersection of two maps, calling a function …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTest whether a map is empty.\nTest whether a set is empty.\nTest whether a hash map is empty.\nTest whether a set is empty.\nTest whether a map is a proper submap of another map, …\nTest whether a map is a proper submap of another map, …\nTest whether a map is a proper submap of another map, …\nTest whether a map is a proper submap of another map, …\nTest whether a set is a proper subset of another set, …\nTest whether a set is a proper subset of another set, …\nTest whether a map is a submap of another map, meaning that\nTest whether a map is a submap of another map, meaning that\nTest whether a map is a submap of another map, meaning that\nTest whether a map is a submap of another map, meaning that\nTest whether a set is a subset of another set, meaning that\nTest whether a set is a subset of another set, meaning that\nIterators over immutable data.\nGet an iterator over the key/value pairs of a map.\nCreate an iterator over the contents of the set.\nGet an iterator over the key/value pairs of a hash map.\nGet an iterator over the values in a hash set.\nGet a mutable iterator over the values of a hash map.\nGet an iterator over a map’s keys.\nGet an iterator over a hash map’s keys.\nGet the size of a map.\nGet the size of a set.\nGet the size of a hash map.\nGet the size of a set.\nConstruct an empty map.\nConstruct an empty set.\nConstruct an empty hash map.\nConstruct an empty set.\nConstruct an empty hash map using the same hasher as the …\nConstruct an empty hash set using the same hasher as the …\nAn ordered map.\nConstruct a map from a sequence of key/value pairs.\nAn ordered set.\nConstruct a set from a sequence of values.\nTest whether two maps refer to the same content in memory.\nTest whether two sets refer to the same content in memory.\nTest whether two maps refer to the same content in memory.\nTest whether two sets refer to the same content in memory.\nCreate an iterator over a range of key/value pairs.\nCreate an iterator over a range inside the set.\nConstruct the relative complement between two maps by …\nConstruct the relative complement between two sets, that …\nConstruct the relative complement between two maps by …\nConstruct the relative complement between two sets, that …\nRemove a key/value mapping from a map if it exists.\nRemove a value from a set.\nRemove a key/value pair from a map, if it exists, and …\nRemove a value from a set if it exists.\nRemove the largest value from a set.\nRemove the smallest value from a set.\nRemove a key/value pair from a map, if it exists, and …\nRemove a key/value pair from a map, if it exists, and …\nFilter out values from a map which don’t satisfy a …\nFilter out values from a set which don’t satisfy a …\nConstruct a map with the <code>n</code> smallest keys removed from a …\nConstruct a set with the <code>n</code> smallest values removed from a …\nSplit a map into two, with the left hand map containing …\nSplit a set into two, with the left hand set containing …\nSplit a map into two, with the left hand map containing …\nSplit a set into two, with the left hand set containing …\nConstruct the symmetric difference between two maps by …\nConstruct the symmetric difference between two sets.\nConstruct the symmetric difference between two maps by …\nConstruct the symmetric difference between two sets.\nConstruct the symmetric difference between two maps by …\nConstruct the symmetric difference between two maps by …\nConstruct the symmetric difference between two maps by …\nConstruct the symmetric difference between two maps by …\nConstruct a map with only the <code>n</code> smallest keys from a given …\nConstruct a set with only the <code>n</code> smallest values from a …\nConstruct the union of two maps, keeping the values in the …\nConstruct the union of two sets.\nConstruct the union of two maps, keeping the values in the …\nConstruct the union of two sets.\nConstruct the union of two maps, using a function to decide\nConstruct the union of two maps, using a function to decide\nConstruct the union of two maps, using a function to decide\nConstruct the union of two maps, using a function to decide\nConstruct the union of a sequence of maps, selecting the …\nConstruct the union of multiple sets.\nConstruct the union of a sequence of maps, selecting the …\nConstruct the union of multiple sets.\nConstruct the union of a sequence of maps, using a …\nConstruct the union of a sequence of maps, using a …\nConstruct the union of a sequence of maps, using a …\nConstruct the union of a sequence of maps, using a …\nConstruct a map with a single mapping.\nConstruct a set with a single value.\nConstruct a hash map with a single mapping.\nConstruct a set with a single value.\nConstruct a new map by inserting a key/value mapping into a\nConstruct a new set from the current set with the given …\nConstruct a new hash map by inserting a key/value mapping …\nConstruct a new set from the current set with the given …\nUpdate a value inside multiple levels of data structures.\nConstruct a new map by inserting a key/value mapping into a\nConstruct a new map by inserting a key/value mapping into a\nConstruct a new map by inserting a key/value mapping into a\nConstruct a new hash map by inserting a key/value mapping …\nConstruct a new map by inserting a key/value mapping into a\nConstruct a new map by inserting a key/value mapping into a\nGet an iterator over a map’s values.\nGet an iterator over a hash map’s values.\nA persistent vector.\nConstruct a vector from a sequence of elements.\nConstruct an empty hash map using the provided hasher.\nConstruct an empty hash set using the provided hasher.\nRemove a key/value pair from a map, if it exists.\nConstruct a new set with the given value removed if it’s …\nConstruct a new map without the given key.\nConstruct a new set with the given value removed if it’s …\nRemove the largest key from a map, and return its value as …\nRemove the largest value from a set, and return that value …\nRemove the largest key from a map, and return that key, its\nRemove the smallest key from a map, and return its value as\nRemove the smallest value from a set, and return that …\nRemove the smallest key from a map, and return that key, …\nA consuming iterator over the elements of a map.\nA handle for a key and its associated value.\nAn unordered map.\nA memory pool for the appropriate node type.\nAn iterator over the elements of a map.\nA mutable iterator over the elements of a map.\nAn iterator over the keys of a map.\nAn entry which exists in the map.\nAn entry for a mapping that already exists in the map.\nAn entry which doesn’t exist in the map.\nAn entry for a mapping that does not already exist in the …\nAn iterator over the values of a map.\nCall the provided function to modify the value if the value\nFill the pool with preallocated chunks.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the current value.\nGet a mutable reference to the current value.\nConstruct a hash map from a sequence of key/value pairs.\nOverwrite the current value.\nInsert a value into this entry.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert this entry into its key.\nConvert this entry into a mutable reference.\nGet the key for this entry.\nGet the key for this entry.\nGet the key for this entry.\nCreate a new pool with the given size.\nInsert a default value if there was no value already, and …\nInsert the default value provided if there was no value …\nInsert the default value from the provided function if …\nGet the current size of the pool.\nRemove this entry from the map and return the removed …\nRemove this entry from the map and return the removed …\nA consuming iterator over the elements of a set.\nAn unordered set.\nA memory pool for the appropriate node type.\nAn iterator over the elements of a set.\nFill the pool with preallocated chunks.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstruct a set from a sequence of values.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new pool with the given size.\nGet the current size of the pool.\nCreate an iterator of values using a function to update an …\nThis value has been added to the new set.\nThis value has been added to the new map.\nA consuming iterator over an ordered set.\nA description of a difference between two ordered maps.\nAn iterator over the differences between two maps.\nA handle for a key and its associated value.\nAn iterator over the key/value pairs of a map.\nAn iterator ove the keys of a map.\nA description of a difference between two ordered sets.\nAn iterator over the differences between two ordered sets.\nAn entry which exists in the map.\nAn entry for a mapping that already exists in the map.\nAn ordered map.\nA memory pool for the appropriate node type.\nAn iterator over an ordered set.\nThis value has been removed from the new set.\nThis value has been removed from the new map.\nThis value has been changed between the two sets.\nThis value has been changed between the two maps.\nAn entry which doesn’t exist in the map.\nAn entry for a mapping that does not already exist in the …\nAn iterator over the values of a map.\nCall the provided function to modify the value if the value\nFill the pool with preallocated chunks.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the current value.\nGet a mutable reference to the current value.\nOverwrite the current value.\nInsert a value into this entry.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert this entry into its key.\nConvert this entry into a mutable reference.\nGet the key for this entry.\nGet the key for this entry.\nGet the key for this entry.\nCreate a new pool with the given size.\nInsert a default value if there was no value already, and …\nInsert the default value provided if there was no value …\nInsert the default value from the provided function if …\nConstruct a map from a sequence of key/value pairs.\nGet the current size of the pool.\nRemove this entry from the map and return the removed …\nRemove this entry from the map and return the removed …\nThe new value.\nThe old value.\nThe new value.\nThe old value.\nThis value has been added to the new set.\nA consuming iterator over the elements of a set.\nA description of a difference between two ordered sets.\nAn iterator over the difference between two sets.\nAn iterator over the elements of a set.\nAn ordered set.\nA memory pool for the appropriate node type.\nA ranged iterator over the elements of a set.\nThis value has been removed from the new set.\nThis value has been changed between the two sets.\nFill the pool with preallocated chunks.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new pool with the given size.\nAdvance the iterator and return the next value.\nAdvance the iterator and return the next value.\nAdvance the iterator and return the next value.\nAdvance the iterator and return the next value.\nConstruct a set from a sequence of values.\nGet the current size of the pool.\nThe new value.\nThe old value.\nAn iterator over the leaf nodes of a vector.\nA mutable iterator over the leaf nodes of a vector.\nA consuming iterator over vectors with values of type <code>A</code>.\nFocused indexing over a <code>Vector</code>.\nA mutable version of <code>Focus</code>.\nAn iterator over vectors with values of type <code>A</code>.\nA mutable iterator over vectors with values of type <code>A</code>.\nA memory pool for <code>Vector</code>.\nA persistent vector.\nAppend the vector <code>other</code> to the end of the current vector.\nGet the last element of a vector.\nGet a mutable reference to the last element of a vector.\nBinary search a sorted vector for a given element.\nBinary search a sorted vector for a given element using a …\nBinary search a sorted vector for a given element with a …\nGet the chunk for the given index.\nGet the chunk for the given index.\nDiscard all elements from the vector.\nTest if a given element is in the vector.\nConstruct a pool with a reasonable default pool size.\nFill the memory pool with preallocated chunks.\nConstruct a <code>Focus</code> for a vector.\nConstruct a <code>FocusMut</code> for a vector.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the first element of a vector.\nGet a mutable reference to the first element of a vector.\nGet a reference to the value at a given index.\nGet a reference to the value at a given index.\nGet a reference to the value at index <code>index</code> in a vector.\nGet a mutable reference to the value at a given index.\nGet a mutable reference to the value at index <code>index</code> in a …\nGet the first element of a vector.\nGet a reference to the value at a given index.\nGet a reference to the value at a given index.\nGet a mutable reference to the value at a given index.\nGet the index of a given element in the vector.\nInsert an element into a vector.\nInsert an element into a sorted vector.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTest if the focused <code>Vector</code> is empty.\nTest if the focused <code>Vector</code> is empty.\nTest whether a vector is empty.\nTest whether a vector is currently inlined.\nGet an iterator over a vector.\nGet a mutable iterator over a vector.\nGet the last element of a vector.\nGet the size of the leaf node subpool.\nGet an iterator over the leaf nodes of a vector.\nGet a mutable iterator over the leaf nodes of a vector. …\nGet the length of the focused <code>Vector</code>.\nGet the length of the focused <code>Vector</code>.\nGet the length of a vector.\nNarrow the focus onto a subslice of the vector.\nNarrow the focus onto a subslice of the vector.\nConstruct a <code>Focus</code> for a <code>Vector</code>.\nConstruct a <code>FocusMut</code> for a <code>Vector</code>.\nCreate a new memory pool with the given size.\nConstruct an empty vector.\nAdvance the iterator and return the next value.\nAdvance the iterator and return the next value.\nAdvance the iterator and return the next value.\nAdvance the iterator and return the next value.\nAdvance the iterator and return the next value.\nAdvance the iterator and return the next value.\nRemove and return an element from the back of the iterator.\nRemove and return an element from the back of the iterator.\nRemove and return an element from the back of the iterator.\nRemove and return an element from the back of the iterator.\nGet the size of the node subpool.\nLookup two indices simultaneously and run a function over …\nRemove the last element from a vector and return it.\nRemove the first element from a vector and return it.\nTest whether two vectors refer to the same content in …\nPush a value to the back of a vector.\nPush a value to the front of a vector.\nParallel iterators.\nRemove an element from a vector.\nRetain only the elements specified by the predicate.\nUpdate the value at a given index.\nUpdate the value at index <code>index</code> in a vector.\nGet the size of the size table subpool.\nConstruct a vector with <code>count</code> elements removed from the …\nExtract a slice from a vector.\nSort a vector.\nSort a vector using a comparator function.\nSplit the focus into two.\nSplit the focus into two.\nSplit a vector at a given index.\nSplit a vector at a given index.\nSwap the values at two given indices.\nSwap the elements at indices <code>i</code> and <code>j</code>.\nConstruct a vector of the first <code>count</code> elements from the …\nLookup three indices simultaneously and run a function …\nTruncate a vector to the given size.\nConstruct a vector with a single value.\nConvert a <code>FocusMut</code> into a <code>Focus</code>.\nCreate a new vector with the value at index <code>index</code> updated.\nCreate a new memory pool with the given sizes for each …\nA parallel iterator for <code>Vector</code>.\nA mutable parallel iterator for <code>Vector</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.")