searchState.loadedDescShard("ark_std", 4, "A (half-open) range bounded inclusively below and …\nA range only bounded inclusively below (<code>start..</code>).\nA range bounded inclusively below and above (<code>start..=end</code>).\nThe upper bound of the range (exclusive).\nThe lower bound of the range (inclusive).\nThe lower bound of the range (inclusive).\nA single-threaded reference-counting pointer. ‘Rc’ …\nA uniquely owned <code>Rc</code>.\n<code>Weak</code> is a version of <code>Rc</code> that holds a non-owning reference …\nReturns a reference to the underlying allocator.\nReturns a reference to the underlying allocator.\nProvides a raw pointer to the data.\nReturns a raw pointer to the object <code>T</code> pointed to by this …\nConverts to <code>Rc&lt;[T]&gt;</code>.\nConverts to <code>Rc&lt;T&gt;</code>.\nMakes a clone of the <code>Rc</code> pointer.\nMakes a clone of the <code>Weak</code> pointer that points to the same …\nComparison for two <code>Rc</code>s.\nComparison for two <code>UniqueRc</code>s.\nDecrements the strong reference count on the <code>Rc&lt;T&gt;</code> …\nDecrements the strong reference count on the <code>Rc&lt;T&gt;</code> …\nCreates an empty str inside an Rc\nCreates an empty <code>[T]</code> inside an Rc\nCreates a new <code>Rc&lt;T&gt;</code>, with the <code>Default</code> value for <code>T</code>.\nCreates an empty CStr inside an Rc\nConstructs a new <code>Weak&lt;T&gt;</code>, without allocating any memory. …\nAttempts to downcast the <code>Rc&lt;dyn Any&gt;</code> to a concrete type.\nDowncasts the <code>Rc&lt;dyn Any&gt;</code> to a concrete type.\nCreates a new <code>Weak</code> pointer to this allocation.\nCreates a new weak reference to the <code>UniqueRc</code>.\nDrops the <code>Rc</code>.\nDrops the <code>Weak</code> pointer.\nEquality for two <code>Rc</code>s.\nEquality for two <code>UniqueRc</code>s.\nConverts a <code>CString</code> into an Rc&lt;CStr&gt; by moving the <code>CString</code> …\nConverts a generic type <code>T</code> into an <code>Rc&lt;T&gt;</code>\nConverts a <code>&amp;CStr</code> into a <code>Rc&lt;CStr&gt;</code>, by copying the contents …\nConverts an <code>OsString</code> into an Rc&lt;OsStr&gt; by moving the …\nCopies the string into a newly allocated Rc&lt;OsStr&gt;.\nCopies the string into a newly allocated Rc&lt;OsStr&gt;.\nConverts a <code>PathBuf</code> into an Rc&lt;Path&gt; by moving the <code>PathBuf</code> …\nConverts a <code>Path</code> into an <code>Rc</code> by copying the <code>Path</code> data into a …\nConverts a reference-counted string slice into a byte …\nCreates a reference-counted pointer from a clone-on-write …\nReturns the argument unchanged.\nConverts a <code>&amp;mut CStr</code> into a <code>Rc&lt;CStr&gt;</code>, by copying the …\nAllocates a reference-counted slice and moves <code>v</code>’s items …\nMove a boxed object to a new, reference counted, …\nAllocates a reference-counted string slice and copies <code>v</code> …\nAllocates a reference-counted string slice and copies <code>v</code> …\nAllocates a reference-counted string slice and copies <code>v</code> …\nConverts a <code>Path</code> into an <code>Rc</code> by copying the <code>Path</code> data into a …\nAllocates a reference-counted slice and fills it by …\nAllocates a reference-counted slice and fills it by …\nConverts a <code>[T; N]</code> into an <code>Rc&lt;[T]&gt;</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nTakes each element in the <code>Iterator</code> and collects it into an …\nConstructs an <code>Rc&lt;T&gt;</code> from a raw pointer.\nConverts a raw pointer previously created by <code>into_raw</code> back …\nConstructs an <code>Rc&lt;T, A&gt;</code> from a raw pointer in the provided …\nConverts a raw pointer previously created by <code>into_raw</code> back …\n‘Greater than or equal to’ comparison for two <code>Rc</code>s.\n‘Greater than or equal to’ comparison for two <code>UniqueRc</code>…\nReturns a mutable reference into the given <code>Rc</code>, if there are\nReturns a mutable reference into the given <code>Rc</code>, without any …\nGreater-than comparison for two <code>Rc</code>s.\nGreater-than comparison for two <code>UniqueRc</code>s.\nIncrements the strong reference count on the <code>Rc&lt;T&gt;</code> …\nIncrements the strong reference count on the <code>Rc&lt;T&gt;</code> …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts the reference-counted slice into a …\nReturns the inner value, if the <code>Rc</code> has exactly one strong …\nConsumes the <code>Rc</code>, returning the wrapped pointer.\nConsumes the <code>Weak&lt;T&gt;</code> and turns it into a raw pointer.\nConsumes the <code>Rc</code>, returning the wrapped pointer and …\nConsumes the <code>Weak&lt;T&gt;</code>, returning the wrapped pointer and …\nConverts the <code>UniqueRc</code> into a regular <code>Rc</code>.\n‘Less than or equal to’ comparison for two <code>Rc</code>s.\n‘Less than or equal to’ comparison for two <code>UniqueRc</code>s.\nLess-than comparison for two <code>Rc</code>s.\nLess-than comparison for two <code>UniqueRc</code>s.\nMakes a mutable reference into the given <code>Rc</code>.\nInequality for two <code>Rc</code>s.\nInequality for two <code>UniqueRc</code>s.\nConstructs a new <code>Rc&lt;T&gt;</code>.\nConstructs a new <code>Weak&lt;T&gt;</code>, without allocating any memory. …\nCreates a new <code>UniqueRc</code>.\nConstructs a new <code>Rc&lt;T&gt;</code> while giving you a <code>Weak&lt;T&gt;</code> to the …\nConstructs a new <code>Rc&lt;T, A&gt;</code> in the given allocator while …\nConstructs a new <code>Rc</code> in the provided allocator.\nConstructs a new <code>Weak&lt;T&gt;</code>, without allocating any memory, …\nCreates a new <code>UniqueRc</code> in the provided allocator.\nConstructs a new <code>Rc</code> with uninitialized contents.\nConstructs a new <code>Rc</code> with uninitialized contents in the …\nConstructs a new reference-counted slice with …\nConstructs a new reference-counted slice with …\nConstructs a new <code>Rc</code> with uninitialized contents, with the …\nConstructs a new <code>Rc</code> with uninitialized contents, with the …\nConstructs a new reference-counted slice with …\nConstructs a new reference-counted slice with …\nPartial comparison for two <code>Rc</code>s.\nPartial comparison for two <code>UniqueRc</code>s.\nConstructs a new <code>Pin&lt;Rc&lt;T&gt;&gt;</code>. If <code>T</code> does not implement <code>Unpin</code>…\nConstructs a new <code>Pin&lt;Rc&lt;T&gt;&gt;</code> in the provided allocator. If <code>T</code>…\nReturns <code>true</code> if the two <code>Rc</code>s point to the same allocation …\nReturns <code>true</code> if the two <code>Weak</code>s point to the same allocation …\nGets the number of strong (<code>Rc</code>) pointers to this allocation.\nGets the number of strong (<code>Rc</code>) pointers pointing to this …\nConstructs a new <code>Rc&lt;T&gt;</code>, returning an error if the …\nConstructs a new <code>Rc&lt;T&gt;</code> in the provided allocator, …\nConstructs a new <code>Rc</code> with uninitialized contents, returning …\nConstructs a new <code>Rc</code> with uninitialized contents, in the …\nConstructs a new <code>Rc</code> with uninitialized contents, with the …\nConstructs a new <code>Rc</code> with uninitialized contents, with the …\nReturns the inner value, if the <code>Rc</code> has exactly one strong …\nIf we have the only reference to <code>T</code> then unwrap it. …\nAttempts to upgrade the <code>Weak</code> pointer to an <code>Rc</code>, delaying …\nGets the number of <code>Weak</code> pointers to this allocation.\nGets the number of <code>Weak</code> pointers pointing to this …\nContains the error value\nAn iterator over the value in a <code>Ok</code> variant of a <code>Result</code>.\nAn iterator over a reference to the <code>Ok</code> variant of a <code>Result</code>.\nAn iterator over a mutable reference to the <code>Ok</code> variant of …\nContains the success value\n<code>Result</code> is a type that represents either success (<code>Ok</code>) or …\nReturns <code>res</code> if the result is <code>Ok</code>, otherwise returns the <code>Err</code> …\nCalls <code>op</code> if the result is <code>Ok</code>, otherwise returns the <code>Err</code> …\nConverts from <code>Result&lt;T, E&gt;</code> (or <code>&amp;Result&lt;T, E&gt;</code>) to …\nConverts from <code>Result&lt;T, E&gt;</code> (or <code>&amp;mut Result&lt;T, E&gt;</code>) to …\nConverts from <code>&amp;mut Result&lt;T, E&gt;</code> to <code>Result&lt;&amp;mut T, &amp;mut E&gt;</code>.\nConverts from <code>&amp;Result&lt;T, E&gt;</code> to <code>Result&lt;&amp;T, &amp;E&gt;</code>.\nMaps a <code>Result&lt;&amp;T, E&gt;</code> to a <code>Result&lt;T, E&gt;</code> by cloning the …\nMaps a <code>Result&lt;&amp;mut T, E&gt;</code> to a <code>Result&lt;T, E&gt;</code> by cloning the …\nMaps a <code>Result&lt;&amp;T, E&gt;</code> to a <code>Result&lt;T, E&gt;</code> by copying the …\nMaps a <code>Result&lt;&amp;mut T, E&gt;</code> to a <code>Result&lt;T, E&gt;</code> by copying the …\nConverts from <code>Result&lt;T, E&gt;</code> to <code>Option&lt;E&gt;</code>.\nReturns the contained <code>Ok</code> value, consuming the <code>self</code> value.\nReturns the contained <code>Err</code> value, consuming the <code>self</code> value.\nConverts from <code>Result&lt;Result&lt;T, E&gt;, E&gt;</code> to <code>Result&lt;T, E&gt;</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nTakes each element in the <code>Iterator</code>: if it is an <code>Err</code>, no …\nCalls a function with a reference to the contained value …\nCalls a function with a reference to the contained value …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the contained <code>Err</code> value, but never panics.\nReturns a consuming iterator over the possibly contained …\nReturns the contained <code>Ok</code> value, but never panics.\nReturns <code>true</code> if the result is <code>Err</code>.\nReturns <code>true</code> if the result is <code>Err</code> and the value inside of …\nReturns <code>true</code> if the result is <code>Ok</code>.\nReturns <code>true</code> if the result is <code>Ok</code> and the value inside of …\nReturns an iterator over the possibly contained value.\nReturns a mutable iterator over the possibly contained …\nMaps a <code>Result&lt;T, E&gt;</code> to <code>Result&lt;U, E&gt;</code> by applying a function …\nMaps a <code>Result&lt;T, E&gt;</code> to <code>Result&lt;T, F&gt;</code> by applying a function …\nReturns the provided default (if <code>Err</code>), or applies a …\nMaps a <code>Result&lt;T, E&gt;</code> to a <code>U</code> by applying function <code>f</code> to the …\nMaps a <code>Result&lt;T, E&gt;</code> to <code>U</code> by applying fallback function …\nConverts from <code>Result&lt;T, E&gt;</code> to <code>Option&lt;T&gt;</code>.\nReturns <code>res</code> if the result is <code>Err</code>, otherwise returns the <code>Ok</code> …\nCalls <code>op</code> if the result is <code>Err</code>, otherwise returns the <code>Ok</code> …\nTakes each element in the <code>Iterator</code>: if it is an <code>Err</code>, no …\nTakes each element in the <code>Iterator</code>: if it is an <code>Err</code>, no …\nTransposes a <code>Result</code> of an <code>Option</code> into an <code>Option</code> of a <code>Result</code>…\nReturns the contained <code>Ok</code> value, consuming the <code>self</code> value.\nReturns the contained <code>Err</code> value, consuming the <code>self</code> value.\nReturns the contained <code>Err</code> value, consuming the <code>self</code> value, …\nReturns the contained <code>Ok</code> value or a provided default.\nReturns the contained <code>Ok</code> value or a default\nReturns the contained <code>Ok</code> value or computes it from a …\nReturns the contained <code>Ok</code> value, consuming the <code>self</code> value, …\nThe number of bytes in a bitmask with this many lanes.\nThis type, reinterpreted as bytes.\nMap from the elements of the input vector to the output …\nNumber of elements in this vector.\nSpecifies the number of lanes in a SIMD vector as a type.\nA SIMD vector mask for <code>N</code> elements of width specified by …\nThe mask element type corresponding to this element type.\nMarker trait for types that may be used as SIMD mask …\nA SIMD vector with the shape of <code>[T; N]</code> but the operations …\nSupporting trait for <code>Simd::cast</code>.  Typically doesn’t need …\nMarker trait for types that may be used as SIMD vector …\nStatically guarantees that a lane count is marked as …\nCreates a vector from the elements of another vector.\nConverts SIMD vectors to vectors of bytes\nReturns true if all elements are set, or false otherwise.\nReturns true if any element is set, or false otherwise.\nReturns an array reference containing the entire SIMD …\nReturns a mutable array reference containing the entire …\nConverts the mask to a mask of any other element size.\nTraits for comparing and ordering vectors.\nCreates a new vector from the elements of <code>first</code> and <code>second</code>.\nCreates a new mask from the elements of <code>first</code> and <code>second</code>.\nWrites a SIMD vector to the first <code>N</code> elements of a slice.\nDeinterleave two masks.\nDeinterleave two vectors.\nExtract a vector from another vector.\nExtract a vector from another vector.\nA SIMD vector with one element of type <code>f32</code>.\nA SIMD vector with 16 elements of type <code>f32</code>.\nA SIMD vector with two elements of type <code>f32</code>.\nA SIMD vector with 32 elements of type <code>f32</code>.\nA SIMD vector with four elements of type <code>f32</code>.\nA SIMD vector with 64 elements of type <code>f32</code>.\nA SIMD vector with eight elements of type <code>f32</code>.\nA SIMD vector with one element of type <code>f64</code>.\nA SIMD vector with 16 elements of type <code>f64</code>.\nA SIMD vector with two elements of type <code>f64</code>.\nA SIMD vector with 32 elements of type <code>f64</code>.\nA SIMD vector with four elements of type <code>f64</code>.\nA SIMD vector with 64 elements of type <code>f64</code>.\nA SIMD vector with eight elements of type <code>f64</code>.\nFinds the index of the first set element.\nA <code>Simd&lt;T, N&gt;</code> has a debug format like the one for <code>[T]</code>:\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts an array of bools to a SIMD mask.\nConverts an array to a SIMD vector.\nCreates an integer value from its representation as a byte …\nCreates a mask from a bitmask.\nConverts a vector of integers to a mask, where 0 …\nConverts a vector of integers to a mask, where 0 …\nCreates an integer value from its representation as a byte …\nCreates a native endian integer value from its memory …\nConverts a slice to a SIMD vector containing <code>slice[..N]</code>.\nReads from potentially discontiguous indices in <code>slice</code> to …\nReads from indices in <code>slice</code> to construct a SIMD vector. If …\nReads elementwise from pointers into a SIMD vector.\nReads from indices in <code>slice</code> to construct a SIMD vector. …\nConditionally read elementwise from pointers into a SIMD …\nReads from indices in <code>slice</code> to construct a SIMD vector. …\nA SIMD vector with one element of type <code>i16</code>.\nA SIMD vector with 16 elements of type <code>i16</code>.\nA SIMD vector with two elements of type <code>i16</code>.\nA SIMD vector with 32 elements of type <code>i16</code>.\nA SIMD vector with four elements of type <code>i16</code>.\nA SIMD vector with 64 elements of type <code>i16</code>.\nA SIMD vector with eight elements of type <code>i16</code>.\nA SIMD vector with one element of type <code>i32</code>.\nA SIMD vector with 16 elements of type <code>i32</code>.\nA SIMD vector with two elements of type <code>i32</code>.\nA SIMD vector with 32 elements of type <code>i32</code>.\nA SIMD vector with four elements of type <code>i32</code>.\nA SIMD vector with 64 elements of type <code>i32</code>.\nA SIMD vector with eight elements of type <code>i32</code>.\nA SIMD vector with one element of type <code>i64</code>.\nA SIMD vector with 16 elements of type <code>i64</code>.\nA SIMD vector with two elements of type <code>i64</code>.\nA SIMD vector with 32 elements of type <code>i64</code>.\nA SIMD vector with four elements of type <code>i64</code>.\nA SIMD vector with 64 elements of type <code>i64</code>.\nA SIMD vector with eight elements of type <code>i64</code>.\nA SIMD vector with one element of type <code>i8</code>.\nA SIMD vector with 16 elements of type <code>i8</code>.\nA SIMD vector with two elements of type <code>i8</code>.\nA SIMD vector with 32 elements of type <code>i8</code>.\nA SIMD vector with four elements of type <code>i8</code>.\nA SIMD vector with 64 elements of type <code>i8</code>.\nA SIMD vector with eight elements of type <code>i8</code>.\nInterleave two masks.\nInterleave two vectors.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA SIMD vector with one element of type <code>isize</code>.\nA SIMD vector with 16 elements of type <code>isize</code>.\nA SIMD vector with two elements of type <code>isize</code>.\nA SIMD vector with 32 elements of type <code>isize</code>.\nA SIMD vector with four elements of type <code>isize</code>.\nA SIMD vector with 64 elements of type <code>isize</code>.\nA SIMD vector with eight elements of type <code>isize</code>.\nReturns the number of elements in this SIMD vector.\nReads contiguous elements from <code>slice</code>. Elements are read so …\nReads contiguous elements from <code>slice</code>. Elements are read so …\nReads contiguous elements from <code>slice</code>. Each element is read …\nReads contiguous elements from <code>slice</code>. Each element is read …\nReads contiguous elements starting at <code>ptr</code>. Each element is …\nReads contiguous elements from <code>slice</code>. Each element is read …\nA SIMD mask with one element for vectors with 16-bit …\nA SIMD mask with 16 elements for vectors with 16-bit …\nA SIMD mask with two elements for vectors with 16-bit …\nA SIMD mask with 32 elements for vectors with 16-bit …\nA SIMD mask with four elements for vectors with 16-bit …\nA SIMD mask with 64 elements for vectors with 16-bit …\nA SIMD mask with eight elements for vectors with 16-bit …\nA SIMD mask with one element for vectors with 32-bit …\nA SIMD mask with 16 elements for vectors with 32-bit …\nA SIMD mask with two elements for vectors with 32-bit …\nA SIMD mask with 32 elements for vectors with 32-bit …\nA SIMD mask with four elements for vectors with 32-bit …\nA SIMD mask with 64 elements for vectors with 32-bit …\nA SIMD mask with eight elements for vectors with 32-bit …\nA SIMD mask with one element for vectors with 64-bit …\nA SIMD mask with 16 elements for vectors with 64-bit …\nA SIMD mask with two elements for vectors with 64-bit …\nA SIMD mask with 32 elements for vectors with 64-bit …\nA SIMD mask with four elements for vectors with 64-bit …\nA SIMD mask with 64 elements for vectors with 64-bit …\nA SIMD mask with eight elements for vectors with 64-bit …\nA SIMD mask with one element for vectors with 8-bit …\nA SIMD mask with 16 elements for vectors with 8-bit …\nA SIMD mask with two elements for vectors with 8-bit …\nA SIMD mask with 32 elements for vectors with 8-bit …\nA SIMD mask with four elements for vectors with 8-bit …\nA SIMD mask with 64 elements for vectors with 8-bit …\nA SIMD mask with eight elements for vectors with 8-bit …\nA SIMD mask with one element for vectors with …\nA SIMD mask with 16 elements for vectors with …\nA SIMD mask with two elements for vectors with …\nA SIMD mask with 32 elements for vectors with …\nA SIMD mask with four elements for vectors with …\nA SIMD mask with 64 elements for vectors with …\nA SIMD mask with eight elements for vectors with …\nTraits for vectors with numeric elements.\nThe portable SIMD prelude.\nTraits for vectors of pointers.\nResize a mask.\nResize a vector.\nReverse the order of the elements in the mask.\nReverse the order of the elements in the vector.\nRotates the mask such that the first <code>OFFSET</code> elements of …\nRotates the vector such that the first <code>OFFSET</code> elements of …\nRotates the mask such that the first <code>self.len() - OFFSET</code> …\nRotates the vector such that the first <code>self.len() - OFFSET</code> …\nWrites the values in a SIMD vector to potentially …\nWrites pointers elementwise into a SIMD vector.\nWrites values from a SIMD vector to multiple potentially …\nConditionally write pointers elementwise into a SIMD …\nWrites values from a SIMD vector to multiple potentially …\nChoose elements from two vectors.\nChoose elements from two masks.\nSets the value of the specified element.\nSets the value of the specified element.\nShifts the mask elements to the left by <code>OFFSET</code>, filling in …\nShifts the vector elements to the left by <code>OFFSET</code>, filling …\nShifts the mask elements to the right by <code>OFFSET</code>, filling …\nShifts the vector elements to the right by <code>OFFSET</code>, filling …\nConstructs a new SIMD vector by copying elements from …\nConstructs a mask by setting all elements to the given …\nConstructs a new SIMD vector with all elements set to the …\nConditionally write contiguous elements to <code>slice</code>. The …\nConditionally write contiguous elements starting from <code>ptr</code>. …\nConditionally write contiguous elements to <code>slice</code>. The …\nCreates a new vector from the elements of <code>vector</code>.\nSwizzle a vector of bytes according to the index vector. …\nCreates a new mask from the elements of <code>mask</code>.\nTests the value of the specified element.\nTests the value of the specified element.\nConverts a SIMD mask to an array of bools.\nConverts a SIMD vector to an array.\nReturns the memory representation of this integer as a …\nCreates a bitmask from a mask.\nConverts the mask to a vector of integers, where 0 …\nReturns the memory representation of this integer as a …\nReturns the memory representation of this integer as a …\nA SIMD vector with one element of type <code>u16</code>.\nA SIMD vector with 16 elements of type <code>u16</code>.\nA SIMD vector with two elements of type <code>u16</code>.\nA SIMD vector with 32 elements of type <code>u16</code>.\nA SIMD vector with four elements of type <code>u16</code>.\nA SIMD vector with 64 elements of type <code>u16</code>.\nA SIMD vector with eight elements of type <code>u16</code>.\nA SIMD vector with one element of type <code>u32</code>.\nA SIMD vector with 16 elements of type <code>u32</code>.\nA SIMD vector with two elements of type <code>u32</code>.\nA SIMD vector with 32 elements of type <code>u32</code>.\nA SIMD vector with four elements of type <code>u32</code>.\nA SIMD vector with 64 elements of type <code>u32</code>.\nA SIMD vector with eight elements of type <code>u32</code>.\nA SIMD vector with one element of type <code>u64</code>.\nA SIMD vector with 16 elements of type <code>u64</code>.\nA SIMD vector with two elements of type <code>u64</code>.\nA SIMD vector with 32 elements of type <code>u64</code>.\nA SIMD vector with four elements of type <code>u64</code>.\nA SIMD vector with 64 elements of type <code>u64</code>.\nA SIMD vector with eight elements of type <code>u64</code>.\nA SIMD vector with one element of type <code>u8</code>.\nA SIMD vector with 16 elements of type <code>u8</code>.\nA SIMD vector with two elements of type <code>u8</code>.\nA SIMD vector with 32 elements of type <code>u8</code>.\nA SIMD vector with four elements of type <code>u8</code>.\nA SIMD vector with 64 elements of type <code>u8</code>.\nA SIMD vector with eight elements of type <code>u8</code>.\nA SIMD vector with one element of type <code>usize</code>.\nA SIMD vector with 16 elements of type <code>usize</code>.\nA SIMD vector with two elements of type <code>usize</code>.\nA SIMD vector with 32 elements of type <code>usize</code>.\nA SIMD vector with four elements of type <code>usize</code>.\nA SIMD vector with 64 elements of type <code>usize</code>.\nA SIMD vector with eight elements of type <code>usize</code>.\nThe mask type returned by each comparison.\nParallel <code>Ord</code>.\nParallel <code>PartialEq</code>.\nParallel <code>PartialOrd</code>.\nRestrict each element to a certain interval.\nTest if each element is equal to the corresponding element …\nTest if each element is greater than or equal to the …\nTest if each element is greater than the corresponding …\nTest if each element is less than or equal to the …\nTest if each element is less than the corresponding …\nReturns the element-wise maximum with <code>other</code>.\nReturns the element-wise minimum with <code>other</code>.\nTest if each element is not equal to the corresponding …\nBit representation of this SIMD vector type.\nA SIMD vector with a different element type.\nA SIMD vector with a different element type.\nA SIMD vector with a different element type.\nMask type used for manipulating this SIMD vector type.\nMask type used for manipulating this SIMD vector type.\nScalar type contained by this SIMD vector type.\nScalar type contained by this SIMD vector type.\nScalar type contained by this SIMD vector type.\nOperations on SIMD vectors of floats.\nOperations on SIMD vectors of signed integers.\nOperations on SIMD vectors of unsigned integers.\nA SIMD vector of unsigned integers with the same element …\nProduces a vector where every element has the absolute …\nLanewise absolute value, implemented in Rust. Every …\nLanewise absolute difference. Every element becomes the …\nLanewise absolute difference. Every element becomes the …\nPerforms elementwise conversion of this vector’s …\nPerforms elementwise conversion of this vector’s …\nPerforms elementwise conversion of this vector’s …\nReturns each element with the magnitude of <code>self</code> and the …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nRaw transmutation from an unsigned integer vector type …\nReturns true for each element if its value is neither …\nReturns true for each element if its value is positive …\nReturns true for each element if its value is <code>NaN</code>.\nReturns true for each negative element and false if it is …\nReturns true for each element if its value is neither …\nReturns true for each positive element and false if it is …\nReturns true for each element if it has a negative sign, …\nReturns true for each element if it has a positive sign, …\nReturns true for each element if its value is subnormal.\nReturns the number of leading ones in the binary …\nReturns the number of leading ones in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nTakes the reciprocal (inverse) of each element, <code>1/x</code>.\nReturns the cumulative bitwise “and” across the …\nReturns the cumulative bitwise “and” across the …\nReturns the maximum element in the vector.\nReturns the maximum element in the vector.\nReturns the maximum element in the vector.\nReturns the minimum element in the vector.\nReturns the minimum element in the vector.\nReturns the minimum element in the vector.\nReturns the cumulative bitwise “or” across the …\nReturns the cumulative bitwise “or” across the …\nReducing multiply.  Returns the product of the elements of …\nReturns the product of the elements of the vector, with …\nReturns the product of the elements of the vector, with …\nReturns the sum of the elements of the vector.\nReturns the sum of the elements of the vector, with …\nReturns the sum of the elements of the vector, with …\nReturns the cumulative bitwise “xor” across the …\nReturns the cumulative bitwise “xor” across the …\nReverses the order of bits in each elemnent. The least …\nReverses the order of bits in each elemnent. The least …\nLanewise saturating absolute value, implemented in Rust. …\nLanewise saturating add.\nLanewise saturating add.\nLanewise saturating negation, implemented in Rust. As …\nLanewise saturating subtract.\nLanewise saturating subtract.\nReplaces each element with a number that represents its …\nReturns numbers representing the sign of each element.\nRestrict each element to a certain interval unless it is …\nReturns the maximum of each element.\nReturns the minimum of each element.\nReverses the byte order of each element.\nReverses the byte order of each element.\nRaw transmutation to an unsigned integer vector type with …\nConverts each element from radians to degrees.\nRounds toward zero and converts to the same-width integer …\nConverts each element from degrees to radians.\nReturns the number of trailing ones in the binary …\nReturns the number of trailing ones in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nWrapping negation.\nBit representation of this SIMD vector type.\nA SIMD vector with a different element type.\nA SIMD vector with a different element type.\nA SIMD vector with a different element type.\nVector of const pointers with the same number of elements.\nVector of const pointers with the same number of elements.\nVector of constant pointers to the same type.\nVector of <code>isize</code> with the same number of elements.\nVector of <code>isize</code> with the same number of elements.\nA SIMD vector mask for <code>N</code> elements of width specified by …\nMask type used for manipulating this SIMD vector type.\nMask type used for manipulating this SIMD vector type.\nMask type used for manipulating this SIMD vector type.\nMask type used for manipulating this SIMD vector type.\nThe mask type returned by each comparison.\nVector of mutable pointers to the same type.\nScalar type contained by this SIMD vector type.\nScalar type contained by this SIMD vector type.\nScalar type contained by this SIMD vector type.\nA SIMD vector with the shape of <code>[T; N]</code> but the operations …\nOperations on SIMD vectors of constant pointers.\nOperations on SIMD vectors of floats.\nOperations on SIMD vectors of signed integers.\nOperations on SIMD vectors of mutable pointers.\nParallel <code>Ord</code>.\nParallel <code>PartialEq</code>.\nParallel <code>PartialOrd</code>.\nOperations on SIMD vectors of unsigned integers.\nA SIMD vector of unsigned integers with the same element …\nVector of <code>usize</code> with the same number of elements.\nVector of <code>usize</code> with the same number of elements.\nProduces a vector where every element has the absolute …\nLanewise absolute value, implemented in Rust. Every …\nLanewise absolute difference. Every element becomes the …\nLanewise absolute difference. Every element becomes the …\nGets the “address” portion of the pointer.\nGets the “address” portion of the pointer.\nPerforms elementwise conversion of this vector’s …\nPerforms elementwise conversion of this vector’s …\nPerforms elementwise conversion of this vector’s …\nCasts to a pointer of another type.\nCasts to a pointer of another type.\nChanges constness without changing the type.\nChanges constness without changing the type.\nReturns each element with the magnitude of <code>self</code> and the …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nExposes the “provenance” part of the pointer for …\nExposes the “provenance” part of the pointer for …\nA SIMD vector with one element of type <code>f32</code>.\nA SIMD vector with 16 elements of type <code>f32</code>.\nA SIMD vector with two elements of type <code>f32</code>.\nA SIMD vector with 32 elements of type <code>f32</code>.\nA SIMD vector with four elements of type <code>f32</code>.\nA SIMD vector with 64 elements of type <code>f32</code>.\nA SIMD vector with eight elements of type <code>f32</code>.\nA SIMD vector with one element of type <code>f64</code>.\nA SIMD vector with 16 elements of type <code>f64</code>.\nA SIMD vector with two elements of type <code>f64</code>.\nA SIMD vector with 32 elements of type <code>f64</code>.\nA SIMD vector with four elements of type <code>f64</code>.\nA SIMD vector with 64 elements of type <code>f64</code>.\nA SIMD vector with eight elements of type <code>f64</code>.\nRaw transmutation from an unsigned integer vector type …\nA SIMD vector with one element of type <code>i16</code>.\nA SIMD vector with 16 elements of type <code>i16</code>.\nA SIMD vector with two elements of type <code>i16</code>.\nA SIMD vector with 32 elements of type <code>i16</code>.\nA SIMD vector with four elements of type <code>i16</code>.\nA SIMD vector with 64 elements of type <code>i16</code>.\nA SIMD vector with eight elements of type <code>i16</code>.\nA SIMD vector with one element of type <code>i32</code>.\nA SIMD vector with 16 elements of type <code>i32</code>.\nA SIMD vector with two elements of type <code>i32</code>.\nA SIMD vector with 32 elements of type <code>i32</code>.\nA SIMD vector with four elements of type <code>i32</code>.\nA SIMD vector with 64 elements of type <code>i32</code>.\nA SIMD vector with eight elements of type <code>i32</code>.\nA SIMD vector with one element of type <code>i64</code>.\nA SIMD vector with 16 elements of type <code>i64</code>.\nA SIMD vector with two elements of type <code>i64</code>.\nA SIMD vector with 32 elements of type <code>i64</code>.\nA SIMD vector with four elements of type <code>i64</code>.\nA SIMD vector with 64 elements of type <code>i64</code>.\nA SIMD vector with eight elements of type <code>i64</code>.\nA SIMD vector with one element of type <code>i8</code>.\nA SIMD vector with 16 elements of type <code>i8</code>.\nA SIMD vector with two elements of type <code>i8</code>.\nA SIMD vector with 32 elements of type <code>i8</code>.\nA SIMD vector with four elements of type <code>i8</code>.\nA SIMD vector with 64 elements of type <code>i8</code>.\nA SIMD vector with eight elements of type <code>i8</code>.\nReturns true for each element if its value is neither …\nReturns true for each element if its value is positive …\nReturns true for each element if its value is <code>NaN</code>.\nReturns true for each negative element and false if it is …\nReturns true for each element if its value is neither …\nReturns <code>true</code> for each element that is null.\nReturns <code>true</code> for each element that is null.\nReturns true for each positive element and false if it is …\nReturns true for each element if it has a negative sign, …\nReturns true for each element if it has a positive sign, …\nReturns true for each element if its value is subnormal.\nA SIMD vector with one element of type <code>isize</code>.\nA SIMD vector with 16 elements of type <code>isize</code>.\nA SIMD vector with two elements of type <code>isize</code>.\nA SIMD vector with 32 elements of type <code>isize</code>.\nA SIMD vector with four elements of type <code>isize</code>.\nA SIMD vector with 64 elements of type <code>isize</code>.\nA SIMD vector with eight elements of type <code>isize</code>.\nReturns the number of leading ones in the binary …\nReturns the number of leading ones in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nA SIMD mask with one element for vectors with 16-bit …\nA SIMD mask with 16 elements for vectors with 16-bit …\nA SIMD mask with two elements for vectors with 16-bit …\nA SIMD mask with 32 elements for vectors with 16-bit …\nA SIMD mask with four elements for vectors with 16-bit …\nA SIMD mask with 64 elements for vectors with 16-bit …\nA SIMD mask with eight elements for vectors with 16-bit …\nA SIMD mask with one element for vectors with 32-bit …\nA SIMD mask with 16 elements for vectors with 32-bit …\nA SIMD mask with two elements for vectors with 32-bit …\nA SIMD mask with 32 elements for vectors with 32-bit …\nA SIMD mask with four elements for vectors with 32-bit …\nA SIMD mask with 64 elements for vectors with 32-bit …\nA SIMD mask with eight elements for vectors with 32-bit …\nA SIMD mask with one element for vectors with 64-bit …\nA SIMD mask with 16 elements for vectors with 64-bit …\nA SIMD mask with two elements for vectors with 64-bit …\nA SIMD mask with 32 elements for vectors with 64-bit …\nA SIMD mask with four elements for vectors with 64-bit …\nA SIMD mask with 64 elements for vectors with 64-bit …\nA SIMD mask with eight elements for vectors with 64-bit …\nA SIMD mask with one element for vectors with 8-bit …\nA SIMD mask with 16 elements for vectors with 8-bit …\nA SIMD mask with two elements for vectors with 8-bit …\nA SIMD mask with 32 elements for vectors with 8-bit …\nA SIMD mask with four elements for vectors with 8-bit …\nA SIMD mask with 64 elements for vectors with 8-bit …\nA SIMD mask with eight elements for vectors with 8-bit …\nA SIMD mask with one element for vectors with …\nA SIMD mask with 16 elements for vectors with …\nA SIMD mask with two elements for vectors with …\nA SIMD mask with 32 elements for vectors with …\nA SIMD mask with four elements for vectors with …\nA SIMD mask with 64 elements for vectors with …\nA SIMD mask with eight elements for vectors with …\nTakes the reciprocal (inverse) of each element, <code>1/x</code>.\nReturns the cumulative bitwise “and” across the …\nReturns the cumulative bitwise “and” across the …\nReturns the maximum element in the vector.\nReturns the maximum element in the vector.\nReturns the maximum element in the vector.\nReturns the minimum element in the vector.\nReturns the minimum element in the vector.\nReturns the minimum element in the vector.\nReturns the cumulative bitwise “or” across the …\nReturns the cumulative bitwise “or” across the …\nReducing multiply.  Returns the product of the elements of …\nReturns the product of the elements of the vector, with …\nReturns the product of the elements of the vector, with …\nReturns the sum of the elements of the vector.\nReturns the sum of the elements of the vector, with …\nReturns the sum of the elements of the vector, with …\nReturns the cumulative bitwise “xor” across the …\nReturns the cumulative bitwise “xor” across the …\nReverses the order of bits in each elemnent. The least …\nReverses the order of bits in each elemnent. The least …\nLanewise saturating absolute value, implemented in Rust. …\nLanewise saturating add.\nLanewise saturating add.\nLanewise saturating negation, implemented in Rust. As …\nLanewise saturating subtract.\nLanewise saturating subtract.\nReplaces each element with a number that represents its …\nReturns numbers representing the sign of each element.\nRestrict each element to a certain interval unless it is …\nRestrict each element to a certain interval.\nTest if each element is equal to the corresponding element …\nTest if each element is greater than or equal to the …\nTest if each element is greater than the corresponding …\nTest if each element is less than or equal to the …\nTest if each element is less than the corresponding …\nReturns the maximum of each element.\nReturns the element-wise maximum with <code>other</code>.\nReturns the minimum of each element.\nReturns the element-wise minimum with <code>other</code>.\nTest if each element is not equal to the corresponding …\nConstructs a new SIMD vector by copying elements from …\nReverses the byte order of each element.\nReverses the byte order of each element.\nRaw transmutation to an unsigned integer vector type with …\nConverts each element from radians to degrees.\nRounds toward zero and converts to the same-width integer …\nConverts each element from degrees to radians.\nReturns the number of trailing ones in the binary …\nReturns the number of trailing ones in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of trailing zeros in the binary …\nA SIMD vector with one element of type <code>u16</code>.\nA SIMD vector with 16 elements of type <code>u16</code>.\nA SIMD vector with two elements of type <code>u16</code>.\nA SIMD vector with 32 elements of type <code>u16</code>.\nA SIMD vector with four elements of type <code>u16</code>.\nA SIMD vector with 64 elements of type <code>u16</code>.\nA SIMD vector with eight elements of type <code>u16</code>.\nA SIMD vector with one element of type <code>u32</code>.\nA SIMD vector with 16 elements of type <code>u32</code>.\nA SIMD vector with two elements of type <code>u32</code>.\nA SIMD vector with 32 elements of type <code>u32</code>.\nA SIMD vector with four elements of type <code>u32</code>.\nA SIMD vector with 64 elements of type <code>u32</code>.\nA SIMD vector with eight elements of type <code>u32</code>.\nA SIMD vector with one element of type <code>u64</code>.\nA SIMD vector with 16 elements of type <code>u64</code>.\nA SIMD vector with two elements of type <code>u64</code>.\nA SIMD vector with 32 elements of type <code>u64</code>.\nA SIMD vector with four elements of type <code>u64</code>.\nA SIMD vector with 64 elements of type <code>u64</code>.\nA SIMD vector with eight elements of type <code>u64</code>.\nA SIMD vector with one element of type <code>u8</code>.\nA SIMD vector with 16 elements of type <code>u8</code>.\nA SIMD vector with two elements of type <code>u8</code>.\nA SIMD vector with 32 elements of type <code>u8</code>.\nA SIMD vector with four elements of type <code>u8</code>.\nA SIMD vector with 64 elements of type <code>u8</code>.\nA SIMD vector with eight elements of type <code>u8</code>.\nA SIMD vector with one element of type <code>usize</code>.\nA SIMD vector with 16 elements of type <code>usize</code>.\nA SIMD vector with two elements of type <code>usize</code>.\nA SIMD vector with 32 elements of type <code>usize</code>.\nA SIMD vector with four elements of type <code>usize</code>.\nA SIMD vector with 64 elements of type <code>usize</code>.\nA SIMD vector with eight elements of type <code>usize</code>.\nCreates a new pointer with the given address.\nCreates a new pointer with the given address.\nConverts an address back to a pointer, picking up a …\nConverts an address back to a pointer, picking up a …\nConverts an address to a pointer without giving it any …\nConverts an address to a pointer without giving it any …\nCalculates the offset from a pointer using wrapping …\nCalculates the offset from a pointer using wrapping …\nWrapping negation.\nCalculates the offset from a pointer using wrapping …\nCalculates the offset from a pointer using wrapping …\nCalculates the offset from a pointer using wrapping …\nCalculates the offset from a pointer using wrapping …\nVector of const pointers with the same number of elements.\nVector of const pointers with the same number of elements.\nVector of constant pointers to the same type.\nVector of <code>isize</code> with the same number of elements.\nVector of <code>isize</code> with the same number of elements.\nMask type used for manipulating this SIMD vector type.\nMask type used for manipulating this SIMD vector type.\nVector of mutable pointers to the same type.\nOperations on SIMD vectors of constant pointers.\nOperations on SIMD vectors of mutable pointers.\nVector of <code>usize</code> with the same number of elements.\nVector of <code>usize</code> with the same number of elements.\nGets the “address” portion of the pointer.\nGets the “address” portion of the pointer.\nCasts to a pointer of another type.\nCasts to a pointer of another type.\nChanges constness without changing the type.\nChanges constness without changing the type.\nExposes the “provenance” part of the pointer for …\nExposes the “provenance” part of the pointer for …\nReturns <code>true</code> for each element that is null.\nReturns <code>true</code> for each element that is null.\nCreates a new pointer with the given address.\nCreates a new pointer with the given address.\nConverts an address back to a pointer, picking up a …\nConverts an address back to a pointer, picking up a …\nConverts an address to a pointer without giving it any …\nConverts an address to a pointer without giving it any …\nCalculates the offset from a pointer using wrapping …\nCalculates the offset from a pointer using wrapping …\nCalculates the offset from a pointer using wrapping …\nCalculates the offset from a pointer using wrapping …\nCalculates the offset from a pointer using wrapping …\nCalculates the offset from a pointer using wrapping …\nAn iterator over a slice in (non-overlapping) chunks (<code>N</code> …\nAn iterator over a slice in (non-overlapping) mutable …\nA windowed iterator over a slice in overlapping chunks (<code>N</code> …\nAn iterator over slice in (non-overlapping) chunks …\nAn iterator over slice in (non-overlapping) mutable chunks …\nAn iterator over a slice in (non-overlapping) chunks (…\nAn iterator over a slice in (non-overlapping) chunks (…\nAn iterator over a slice in (non-overlapping) mutable …\nAn iterator over a slice in (non-overlapping) mutable …\nHelper trait for <code>[T]::concat</code>.\nAn iterator over the escaped version of a byte slice.\nThe error type returned by <code>get_disjoint_mut</code>.\nA helper trait for <code>&lt;[T]&gt;::get_disjoint_mut()</code>.\nAn index provided was out-of-bounds for the slice.\nThe element type of the slice being matched on.\nImmutable slice iterator\nMutable slice iterator.\nHelper trait for <code>[T]::join</code>\nThe resulting type after concatenation\nThe resulting type after concatenation\nThe output type returned by methods.\nTwo indices provided were overlapping.\nAn iterator over a slice in (non-overlapping) chunks (…\nAn iterator over a slice in (non-overlapping) chunks (…\nAn iterator over a slice in (non-overlapping) mutable …\nAn iterator over a slice in (non-overlapping) mutable …\nAn iterator over subslices separated by elements that …\nAn iterator over the subslices of the vector which are …\nAn iterator over subslices separated by elements that …\nAn iterator over subslices separated by elements that …\nA helper trait used for indexing operations.\nPatterns in slices - currently, only used by <code>strip_prefix</code> …\nAn iterator over subslices separated by elements that …\nAn iterator over subslices separated by elements that …\nAn iterator over the mutable subslices of the vector which …\nAn iterator over the mutable subslices of the vector which …\nAn iterator over subslices separated by elements that …\nAn iterator over subslices separated by elements that …\nAn iterator over overlapping subslices of length <code>size</code>.\nViews the underlying data as a mutable subslice of the …\nCurrently, the consumers of <code>SlicePattern</code> need a slice.\nViews the underlying data as a subslice of the original …\nViews the underlying data as a subslice of the original …\nReturns a slice which contains items not yet handled by …\nImplementation of <code>[T]::concat</code>\nCreates an empty slice iterator.\nCreates an empty slice iterator.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts a reference to T into a slice of length 1 …\nForms a mutable slice from a pointer range.\nForms a slice from a pointer range.\nForms a slice from a pointer and a length.\nPerforms the same functionality as <code>from_raw_parts</code>, except …\nConverts a reference to T into a slice of length 1 …\nReturns a shared reference to the output at this location, …\nReturns a mutable reference to the output at this …\nReturns a pointer to the output at this location, without …\nReturns a mutable pointer to the output at this location, …\nReturns a shared reference to the output at this location, …\nReturns a mutable reference to the output at this …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the remainder of the original slice that is not …\nReturns the remainder of the original slice that is not …\nReturns the remainder of the original slice that is not …\nViews the underlying data as a subslice of the original …\nReturns <code>true</code> if <code>self</code> is in bounds for <code>len</code> slice elements.\nReturns <code>true</code> if <code>self</code> overlaps with <code>other</code>.\nImplementation of <code>[T]::join</code>\nPerforms bounds checking of a range.\nReturns the remainder of the original slice that is not …\nReturns the remainder of the original slice that is not …\nReturns the remainder of the original slice that is not …\nPerforms bounds checking of a range without panicking.\nAn iterator over the bytes of a string slice.\nAn iterator over the <code>char</code>s of a string slice, and their …\nAn iterator over the <code>char</code>s of a string slice.\nAn iterator of <code>u16</code> over the string encoded as UTF-16.\nThe associated error which can be returned from parsing.\nThe return type of <code>str::escape_debug</code>.\nThe return type of <code>str::escape_default</code>.\nThe return type of <code>str::escape_unicode</code>.\nParse a value from a string\nAn iterator over the lines of a string, as string slices.\nCreated with the method <code>lines_any</code>.\nCreated with the method <code>match_indices</code>.\nCreated with the method <code>matches</code>.\nAn error returned when parsing a <code>bool</code> using <code>from_str</code> fails\nCreated with the method <code>rmatch_indices</code>.\nCreated with the method <code>rmatches</code>.\nCreated with the method <code>rsplit</code>.\nCreated with the method <code>rsplitn</code>.\nCreated with the method <code>rsplit_terminator</code>.\nCreated with the method <code>split</code>.\nAn iterator over the non-ASCII-whitespace substrings of a …\nAn iterator over the substrings of a string, terminated by …\nCreated with the method <code>splitn</code>.\nCreated with the method <code>split_terminator</code>.\nAn iterator over the non-whitespace substrings of a string,\nAn item returned by the <code>Utf8Chunks</code> iterator.\nAn iterator used to decode a slice of mostly UTF-8 bytes …\nErrors which can occur when attempting to interpret a …\nViews the underlying data as a subslice of the original …\nViews the underlying data as a subslice of the original …\nProvides more information about the failure:\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts a boxed slice of bytes to a boxed string slice …\nCreates a <code>&amp;str</code> from a pointer and a length.\nCreates a <code>&amp;mut str</code> from a pointer and a length.\nParses a string <code>s</code> to return a value of this type.\nConverts a slice of bytes to a string slice.\nConverts a mutable slice of bytes to a mutable string …\nConverts a slice of bytes to a string slice without …\nConverts a slice of bytes to a string slice without …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the invalid sequence that caused a failure.\nReads the next code point out of a byte iterator (assuming …\nReturns the byte position of the next character, or the …\nThe string Pattern API.\nReturns remainder of the split string.\nReturns remainder of the split string.\nReturns remainder of the split string.\nReturns remainder of the split string.\nReturns remainder of the split string.\nReturns remainder of the split string.\nReturns remainder of the split string.\nReturns the remaining lines of the split string.\nReturns remainder of the split string\nReturns remainder of the split string.\nGiven a first byte, determines how many bytes are in this …\nReturns the next validated UTF-8 substring.\nReturns the index in the given string up to which valid …\nAssociated type for <code>&lt;&amp;[char; N] as Pattern&gt;::Searcher&lt;&#39;a&gt;</code>.\nAssociated type for <code>&lt;[char; N] as Pattern&gt;::Searcher&lt;&#39;a&gt;</code>.\nType returned by char types.\nAssociated type for <code>&lt;F as Pattern&gt;::Searcher&lt;&#39;a&gt;</code>.\nAssociated type for <code>&lt;char as Pattern&gt;::Searcher&lt;&#39;a&gt;</code>.\nAssociated type for <code>&lt;&amp;[char] as Pattern&gt;::Searcher&lt;&#39;a&gt;</code>.\nExpresses that every byte of the haystack has been …\nA marker trait to express that a <code>ReverseSearcher</code> can be …\nExpresses that a match of the pattern has been found at …\nA string pattern.\nExpresses that <code>haystack[a..b]</code> has been rejected as a …\nA reverse searcher for a string pattern.\nResult of calling <code>Searcher::next()</code> or …\nA searcher for a string pattern.\nAssociated searcher for this pattern\nAssociated type for <code>&lt;&amp;str as Pattern&gt;::Searcher&lt;&#39;a&gt;</code>.\nType returned by String and str types.\nResult of calling <code>Pattern::as_utf8_pattern()</code>. Can be used …\nReturns the pattern as utf-8 bytes if possible.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGetter for the underlying string to be searched in\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstructs the associated searcher from <code>self</code> and the …\nChecks whether the pattern matches anywhere in the haystack\nChecks whether the pattern matches at the front of the …\nChecks whether the pattern matches at the back of the …\nPerforms the next search step starting from the front.\nPerforms the next search step starting from the back.\nFinds the next <code>Match</code> result. See <code>next()</code>.\nFinds the next <code>Match</code> result. See <code>next_back()</code>.\nFinds the next <code>Reject</code> result. See <code>next()</code> and <code>next_match()</code>.\nFinds the next <code>Reject</code> result. See <code>next_back()</code>.\nRemoves the pattern from the front of haystack, if it …\nRemoves the pattern from the back of haystack, if it …\nA draining iterator for <code>String</code>.\nA possible error value when converting a <code>String</code> from a …\nA possible error value when converting a <code>String</code> from a …\nAn iterator over the <code>char</code>s of a string.\nA type alias for <code>Infallible</code>.\nA UTF-8–encoded, growable string.\nA trait for converting a value to a <code>String</code>.\nReturns a byte slice of this <code>String</code>’s contents.\nReturns a slice of <code>u8</code>s bytes that were attempted to …\nConverts a <code>String</code> into a mutable string slice.\nReturns a mutable reference to the contents of this <code>String</code>.\nReturns the remaining (sub)string of this iterator as a …\nExtracts a string slice containing the entire <code>String</code>.\nViews the underlying data as a subslice of the original …\nReturns this <code>String</code>’s capacity, in bytes.\nTruncates this <code>String</code>, removing all contents.\nClones the contents of <code>source</code> into <code>self</code>.\nCreates an empty <code>String</code>.\nRemoves the specified range from the string in bulk, …\nCopies elements from <code>src</code> range to the end of the string.\nReturns the argument unchanged.\nConverts the given boxed <code>str</code> slice to a <code>String</code>. It is …\nReturns the argument unchanged.\nConverts a <code>&amp;str</code> into a <code>String</code>.\nConverts a <code>&amp;mut str</code> into a <code>String</code>.\nAllocates an owned <code>String</code> from a single character.\nConverts a <code>&amp;String</code> into a <code>String</code>.\nConverts a clone-on-write string to an owned instance of …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new <code>String</code> from a pointer, a length and a …\nDecode a native endian UTF-16–encoded vector <code>v</code> into a …\nDecode a native endian UTF-16–encoded slice <code>v</code> into a …\nDecode a UTF-16BE–encoded vector <code>v</code> into a <code>String</code>, …\nDecode a UTF-16BE–encoded slice <code>v</code> into a <code>String</code>, …\nDecode a UTF-16LE–encoded vector <code>v</code> into a <code>String</code>, …\nDecode a UTF-16LE–encoded slice <code>v</code> into a <code>String</code>, …\nConverts a vector of bytes to a <code>String</code>.\nConverts a slice of bytes to a string, including invalid …\nConverts a <code>Vec&lt;u8&gt;</code> to a <code>String</code>, substituting invalid UTF-8 …\nConverts a vector of bytes to a <code>String</code> without checking …\nInserts a character into this <code>String</code> at byte position <code>idx</code>.\nInserts a string slice into this <code>String</code> at byte position …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts this <code>String</code> into a Box&lt;str&gt;.\nConverts a <code>String</code> into a byte vector.\nReturns the bytes that were attempted to convert to a …\nConverts a <code>String</code> into an iterator over the <code>char</code>s of the …\nDecomposes a <code>String</code> into its raw components: …\nConsumes the <code>IntoChars</code>, returning the remaining string.\nConverts the bytes into a <code>String</code> lossily, substituting …\nReturns <code>true</code> if this <code>String</code> has a length of zero, and <code>false</code>…\nConsumes and leaks the <code>String</code>, returning a mutable …\nReturns the length of this <code>String</code>, in bytes, not <code>char</code>s or …\nCreates a new empty <code>String</code>.\nRemoves the last character from the string buffer and …\nAppends the given <code>char</code> to the end of this <code>String</code>.\nAppends a given string slice onto the end of this <code>String</code>.\nRemoves a <code>char</code> from this <code>String</code> at byte position <code>idx</code> and …\nRemove all matches of pattern <code>pat</code> in the <code>String</code>.\nRemoves the specified range in the string, and replaces it …\nReserves capacity for at least <code>additional</code> bytes more than …\nReserves the minimum capacity for at least <code>additional</code> …\nRetains only the characters specified by the predicate.\nShrinks the capacity of this <code>String</code> with a lower bound.\nShrinks the capacity of this <code>String</code> to match its length.\nSplits the string into two at the given byte index.\nConverts the given value to a <code>String</code>.\nShortens this <code>String</code> to the specified length.\nConverts a <code>CString</code> into a <code>String</code> if it contains valid …\nConverts the given <code>Vec&lt;u8&gt;</code> into a  <code>String</code> if it contains …\nTries to reserve capacity for at least <code>additional</code> bytes …\nTries to reserve the minimum capacity for at least …\nCreates a new empty <code>String</code> with at least the specified …\nFetch a <code>Utf8Error</code> to get more details about the conversion …\nCreates a new empty <code>String</code> with at least the specified …\nA <code>Duration</code> type to represent a span of time, typically …\nThe maximum duration.\nThe duration of one microsecond.\nThe duration of one millisecond.\nThe duration of one nanosecond.\nThe duration of one second.\nAn error which can be returned when converting a …\nA duration of zero time.\nComputes the absolute difference between <code>self</code> and <code>other</code>.\nReturns the total number of whole microseconds contained …\nReturns the total number of whole milliseconds contained …\nReturns the number of milliseconds contained by this …\nReturns the number of milliseconds contained by this …\nReturns the total number of nanoseconds contained by this …\nReturns the number of <em>whole</em> seconds contained by this …\nReturns the number of seconds contained by this <code>Duration</code> …\nReturns the number of seconds contained by this <code>Duration</code> …\nChecked <code>Duration</code> addition. Computes <code>self + other</code>, …\nChecked <code>Duration</code> division. Computes <code>self / other</code>, …\nChecked <code>Duration</code> multiplication. Computes <code>self * other</code>, …\nChecked <code>Duration</code> subtraction. Computes <code>self - other</code>, …\nDivides <code>Duration</code> by <code>Duration</code> and returns <code>f32</code>.\nDivides <code>Duration</code> by <code>Duration</code> and returns <code>f64</code>.\nDivides <code>Duration</code> by <code>f32</code>.\nDivides <code>Duration</code> by <code>f64</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new <code>Duration</code> from the specified number of days.\nCreates a new <code>Duration</code> from the specified number of hours.\nCreates a new <code>Duration</code> from the specified number of …\nCreates a new <code>Duration</code> from the specified number of …\nCreates a new <code>Duration</code> from the specified number of …\nCreates a new <code>Duration</code> from the specified number of …\nCreates a new <code>Duration</code> from the specified number of whole …\nCreates a new <code>Duration</code> from the specified number of …\nCreates a new <code>Duration</code> from the specified number of …\nCreates a new <code>Duration</code> from the specified number of weeks.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if this <code>Duration</code> spans no time.\nMultiplies <code>Duration</code> by <code>f32</code>.\nMultiplies <code>Duration</code> by <code>f64</code>.\nCreates a new <code>Duration</code> from the specified number of whole …\nSaturating <code>Duration</code> addition. Computes <code>self + other</code>, …\nSaturating <code>Duration</code> multiplication. Computes <code>self * other</code>, …\nSaturating <code>Duration</code> subtraction. Computes <code>self - other</code>, …\nReturns the fractional part of this <code>Duration</code>, in whole …\nReturns the fractional part of this <code>Duration</code>, in whole …\nReturns the fractional part of this <code>Duration</code>, in …\nThe checked version of <code>from_secs_f32</code>.\nThe checked version of <code>from_secs_f64</code>.\nThe largest value that can be represented by this integer …\nThe smallest value that can be represented by this integer …\nThe largest value that can be represented by this integer …\nThe smallest value that can be represented by this integer …\nThe largest value that can be represented by this integer …\nThe smallest value that can be represented by this integer …\nThe largest value that can be represented by this integer …\nThe smallest value that can be represented by this integer …\nThe largest value that can be represented by this integer …\nThe smallest value that can be represented by this integer …\nChecks that the preconditions of an unsafe function are …\nReturns whether we should perform some UB-checking at …\nThe version of Unicode that the Unicode parts of <code>char</code> and …\nUnwrap an unsafe binder into its underlying type.\nWrap a type into an unsafe binder.\nThe largest value that can be represented by this integer …\nThe smallest value that can be represented by this integer …\nA draining iterator for <code>Vec&lt;T&gt;</code>.\nAn iterator which uses a closure to determine if an …\nAn iterator that moves out of a vector.\nStructure wrapping a mutable reference to the last item in …\nA splicing iterator for <code>Vec</code>.\nA contiguous growable array type, written as <code>Vec&lt;T&gt;</code>, short …\nReturns a reference to the underlying allocator.\nReturns a reference to the underlying allocator.\nReturns a reference to the underlying allocator.\nReturns a reference to the underlying allocator.\nMoves all the elements of <code>other</code> into <code>self</code>, leaving <code>other</code> …\nReturns a raw mutable pointer to the vector’s buffer, or …\nReturns the remaining items of this iterator as a mutable …\nExtracts a mutable slice of the entire vector.\nReturns a <code>NonNull</code> pointer to the vector’s buffer, or a …\nReturns a raw pointer to the vector’s buffer, or a …\nReturns the remaining items of this iterator as a slice.\nReturns the remaining items of this iterator as a slice.\nExtracts a slice containing the entire vector.\nReturns the total number of elements the vector can hold …\nClears the vector, removing all values.\nOverwrites the contents of <code>self</code> with a clone of the …\nRemoves consecutive repeated elements in the vector …\nRemoves all but the first of consecutive elements in the …\nRemoves all but the first of consecutive elements in the …\nCreates an empty <code>vec::IntoIter</code>.\nCreates an empty <code>Vec&lt;T&gt;</code>.\nRemoves the subslice indicated by the given range from the …\nClones and appends all elements in a slice to the <code>Vec</code>.\nGiven a range <code>src</code>, clones a slice of elements in that …\nCreates an iterator which uses a closure to determine if …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAllocates a <code>Vec&lt;u8&gt;</code> and fills it with a UTF-8 string.\nConverts a boxed slice into a vector by transferring …\nConverts a clone-on-write slice into a vector.\nAllocates a <code>Vec&lt;T&gt;</code> and moves <code>s</code>’s items into it.\nAllocates a <code>Vec&lt;T&gt;</code> and fills it by cloning <code>s</code>’s items.\nConverts a <code>CString</code> into a Vec&lt;u8&gt;.\nConverts the given <code>String</code> to a vector <code>Vec</code> that holds …\nAllocates a <code>Vec&lt;T&gt;</code> and fills it by cloning <code>s</code>’s items.\nAllocates a <code>Vec&lt;T&gt;</code> and fills it by cloning <code>s</code>’s items.\nTurn a <code>VecDeque&lt;T&gt;</code> into a <code>Vec&lt;T&gt;</code>.\nConverts a <code>BinaryHeap&lt;T&gt;</code> into a <code>Vec&lt;T&gt;</code>.\nAllocates a <code>Vec&lt;T&gt;</code> and fills it by cloning <code>s</code>’s items.\nReturns the argument unchanged.\nCreates a <code>Vec&lt;T&gt;</code> directly from a <code>NonNull</code> pointer, a …\nCreates a <code>Vec&lt;T, A&gt;</code> directly from a <code>NonNull</code> pointer, a …\nCreates a <code>Vec&lt;T&gt;</code> directly from a pointer, a length, and a …\nCreates a <code>Vec&lt;T, A&gt;</code> directly from a pointer, a length, a …\nInserts an element at position <code>index</code> within the vector, …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts the vector into <code>Box&lt;[T]&gt;</code>.\nTakes a <code>Vec&lt;[T; N]&gt;</code> and flattens it into a <code>Vec&lt;T&gt;</code>.\nCreates a consuming iterator, that is, one that moves each …\nDecomposes a <code>Vec&lt;T&gt;</code> into its raw components: …\nDecomposes a <code>Vec&lt;T&gt;</code> into its raw components: …\nDecomposes a <code>Vec&lt;T&gt;</code> into its raw components: …\nDecomposes a <code>Vec&lt;T&gt;</code> into its raw components: …\nReturns <code>true</code> if the vector contains no elements.\nKeep unyielded elements in the source <code>Vec</code>.\nConsumes and leaks the <code>Vec</code>, returning a mutable reference …\nReturns the number of elements in the vector, also …\nConstructs a new, empty <code>Vec&lt;T&gt;</code>.\nConstructs a new, empty <code>Vec&lt;T, A&gt;</code>.\nReturns a mutable reference to the last item in the …\nRemoves the peeked value from the vector and returns it.\nRemoves the last element from a vector and returns it, or …\nRemoves and returns the last element from a vector if the …\nAppends an element to the back of a collection.\nAppends an element if there is sufficient spare capacity, …\nRemoves and returns the element at position <code>index</code> within …\nReserves capacity for at least <code>additional</code> more elements to …\nReserves the minimum capacity for at least <code>additional</code> more …\nResizes the <code>Vec</code> in-place so that <code>len</code> is equal to <code>new_len</code>.\nResizes the <code>Vec</code> in-place so that <code>len</code> is equal to <code>new_len</code>.\nRetains only the elements specified by the predicate.\nRetains only the elements specified by the predicate, …\nForces the length of the vector to <code>new_len</code>.\nShrinks the capacity of the vector with a lower bound.\nShrinks the capacity of the vector as much as possible.\nReturns the remaining spare capacity of the vector as a …\nCreates a splicing iterator that replaces the specified …\nReturns vector content as a slice of <code>T</code>, along with the …\nSplits the collection into two at the given index.\nRemoves an element from the vector and returns it.\nShortens the vector, keeping the first <code>len</code> elements and …\nTries to reserve capacity for at least <code>additional</code> more …\nTries to reserve the minimum capacity for at least …\nConstructs a new, empty <code>Vec&lt;T&gt;</code> with at least the specified …\nConstructs a new, empty <code>Vec&lt;T, A&gt;</code> with at least the …\nConstructs a new, empty <code>Vec&lt;T&gt;</code> with at least the specified …\nConstructs a new, empty <code>Vec&lt;T, A&gt;</code> with at least the …")