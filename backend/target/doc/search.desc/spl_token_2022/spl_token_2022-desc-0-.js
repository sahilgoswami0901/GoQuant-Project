searchState.loadedDescShard("spl_token_2022", 0, "An ERC20-like Token program for the Solana blockchain\nThe const program ID.\nConvert a raw amount to its UI representation (using the …\nConvert a raw amount to its UI representation (using the …\nConvert a raw amount to its UI representation using the …\nReturns <code>true</code> if given pubkey is the program ID.\nChecks that the supplied program ID is correct for …\nChecks that the supplied program ID is corect for …\nChecks if the spplied program ID is that of the system …\nChecks that the supplied program ID is correct for the ZK …\nChecks two pubkeys for equality in a computationally cheap …\nError types\nExtensions available to token mints and accounts\nGeneric Token Account, copied from spl_token::state\nReturns the program ID.\nInstruction types\nThe Mint that represents the native token\nOffchain helper for fetching required accounts to build …\nOn-chain program invoke helper to perform on-chain …\nProgram state processor\nHelper for processing instruction data from ZK Token proof …\nState transition types\nTry to convert a UI representation of a token amount to …\nConvert the UI representation of a token amount (using the …\nFailed to decrypt a confidential transfer account\nAccount is frozen; all account operations will fail\nAn account can only be closed if its withheld fee balance …\nThe account cannot be initialized because it is already …\nAccount does not support specified authority type.\nCiphertext arithmetic failed\nAn account can only be closed if its confidential balance …\nAccount not approved for confidential transfers\nBalance mismatch\nAccount not accepting deposits or transfers\nElGamal public key mismatch\nAn account can only be closed if the confidential withheld …\nCPI Guard is enabled, and a program attempted to approve a …\nCPI Guard is enabled, and a program attempted to burn user …\nCPI Guard is enabled, and a program attempted to close an …\nAccount ownership cannot be changed while CPI Guard is …\nCPI Guard is enabled, and a program attempted to add or …\nCPI Guard cannot be enabled or disabled in CPI\nCPI Guard is enabled, and a program attempted to transfer …\nExtension already initialized on this account\nExtension does not match the base type provided\nExtension not found in account data\nExtension type does not match already existing extensions\nCalculated fee does not match expected fee\nFee parameters associated with confidential transfer …\nThis token’s supply is fixed and new tokens cannot be …\nHarvest of withheld tokens to mint is disabled\nThe owner authority cannot be changed\nInsufficient funds for the operation requested.\nA mint or an account is initialized to an invalid …\nInvalid instruction\nExtension allocation with overwrite must use the same …\nInvalid Mint.\nInvalid number of provided signers.\nInvalid number of required signers.\nAn invalid proof instruction offset was provided\nState is invalid for requested operation.\nCiphertext is malformed\nThe deposit amount for the confidential extension exceeds …\nThe total number of <code>Deposit</code> and <code>Transfer</code> instructions to …\nThis token mint cannot freeze accounts.\nMint decimals mismatch between the client and mint\nMint has non-zero supply. Burn all tokens before closing …\nAccount not associated with this Mint.\nMint required for this account to transfer tokens, use …\nInstruction does not support native tokens\nNo authority exists to perform the desired operation\nNo memo in previous instruction; required for recipient to …\nAccount does not accept non-confidential transfers\nNon-native account can only be closed if its balance is …\nInstruction does not support non-native tokens\nTransfer is disabled for this mint\nNon-transferable tokens can’t be minted to an account …\nNot enough proof context state accounts provided\nLamport balance below rent-exempt threshold.\nOperation overflowed\nOwner does not match.\nFailed to generate a zero-knowledge proof needed for a …\nSplit proof context state accounts not supported for …\nErrors that may be returned by the Token program.\nTransfer fee exceeds maximum of 10,000 basis points\nState is uninitialized.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAssociated extension type enum, checked at the start of …\nToken holding account with additional extensions\nDifferent kinds of accounts. Note that <code>Mint</code>, <code>Account</code>, and …\nTrait for base states, specifying the associated enum\nTrait for base state with extension\nState for confidential transfers\nIncludes confidential withheld transfer fees\nIncludes encrypted withheld fees and the encryption public …\nAuditor configuration for confidential transfers\nLocks privileged token operations from happening via CPI\nSpecifies the default Account::state for new Accounts\nTrait to be implemented by all extension states, …\nExtensions that can be applied to mints or accounts.  Mint …\nMint contains a pointer to another account (or the same …\nMint contains a pointer to another account (or the same …\nIndicates that the Account owner authority cannot be …\nTokens accrue interest over time,\nLength in TLV structure\nRequire inbound transfers to have memo\nMint contains a pointer to another account (or the same …\nMint account with additional extensions\nIncludes an optional mint close authority\nIndicates that the tokens from this mint can’t be …\nIndicates that the tokens in this account belong to a …\nIncludes an optional permanent delegate\nEncapsulates immutable base state data (mint or account) …\nEncapsulates mutable base state data (mint or account) …\nEncapsulates owned immutable base state data (mint or …\nAssociated extension type enum, checked at the start of …\nMint contains token group configurations\nMint contains token group member configurations\nMint contains token-metadata\nIncludes withheld transfer fees\nIncludes transfer fee rate info and accompanying …\nMint requires a CPI to a program implementing the “…\nIndicates that the tokens in this account belong to a mint …\nMarker for 0 data\nUsed as padding if the account size would otherwise be …\nPacks a fixed-length extension into a TLV space\nPacks a variable-length extension into a TLV space\nUnpacked base data\nUnpacked base data\nUnpacked base data\nCheck for invalid combination of mint extensions\nConfidential Transfer extension\nConfidential Transfer Fee extension\nCPI Guard extension\nDefault Account State extension\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the associated account type\nUnpack a portion of the TLV data as the desired type\nFetch the bytes for a TLV entry\nUnpack a portion of the TLV data as the base mutable bytes\nUnpack a portion of the TLV data as the desired type that …\nIterates through the TLV entries, returning only the types\nGet just the first extension type, useful to track mixed …\nBased on a set of AccountType::Mint ExtensionTypes, get …\nGet the buffer containing all extension data\nUnpacks a portion of the TLV data as the desired …\nGroup Member Pointer extension\nGroup Pointer extension\nImmutable Owner extension\nIf <code>extension_type</code> is an Account-associated ExtensionType …\nWrite the account type into the buffer, done during the …\nPacks the default extension data into an open slot if not …\nAllocate the given number of bytes for the given …\nInterest-Bearing Mint extension\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMemo Transfer extension\nMetadata Pointer extension\nMint Close Authority extension\nNon Transferable extension\nPacks base state data into the base data portion\nPacks a variable-length extension into its appropriate …\nPermanent Delegate extension\nReallocate and overwite the TLV entry for the given …\nUtility to reallocate token accounts\nIf AccountType is uninitialized, set it to the BaseState’…\nToken-group extension\nToken-metadata extension\nTransfer Fee extension\nTransfer Hook extension\nGet the required account data length for the given …\nGet the total number of bytes used by TLV entries and the …\nCalculate the new expected size if the state allocates the …\nCalculate the new expected size if the state allocates the …\nUnpack base state, leaving the extension data as a slice\nUnpack base state, leaving the extension data as a slice\nUnpack base state, leaving the extension data as a mutable …\nUnpack an uninitialized base state, leaving the extension …\nConfidential account state\nConfidential transfer mint configuration\nAuthenticated encryption containing an account balance\nElGamal ciphertext containing an account balance\nMaximum bit length of any deposit or transfer amount\nBit length of the low bits of pending balance plaintext\nConfidential Transfer Extension account information needed …\nThe actual <code>pending_balance_credit_counter</code> when the last …\nIf <code>false</code>, the extended account rejects any incoming …\nIf <code>false</code>, the base account rejects any incoming transfers\nCheck if a <code>ConfidentialTransferAccount</code> has been approved …\n<code>true</code> if this account has been approved for use. All …\nAuthority to decode any transfer amount in a confidential …\nAuthority to modify the <code>ConfidentialTransferMint</code> …\nIndicate if newly configured accounts must be approved by …\nThe available balance (encrypted by <code>encrypiton_pubkey</code>)\nCiphertext extraction and proof related helper logic\nCheck if a <code>ConfidentialTransferAccount</code> is in a closable …\nThe decryptable available balance\nThe public key associated with ElGamal encryption\nThe <code>expected_pending_balance_credit_counter</code> value that was …\nReturns the argument unchanged.\nReturns the argument unchanged.\nIncrements a confidential extension pending balance credit …\nConfidential Transfer Extension instructions\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe maximum number of <code>Deposit</code> and <code>Transfer</code> instructions …\nCheck if a base account of a <code>ConfidentialTransferAccount</code> …\nThe total number of <code>Deposit</code> and <code>Transfer</code> instructions that …\nThe high 48 bits of the pending balance (encrypted by …\nThe low 16 bits of the pending balance (encrypted by …\nConfidential Transfer Extension processor\nHelper functions to generate split zero-knowledge proofs …\nChecks if a confidential extension is configured to …\nChecks if a <code>ConfidentialTransferAccount</code> is configured to …\nHelper functions to verify zero-knowledge proofs in the …\nConfidential Transfer extension information needed to …\nConfidential transfer extension information needed to …\nConfidential Transfer extension information needed to …\nConfidential Transfer extension information needed to …\nThe available balance (encrypted by <code>encrypiton_pubkey</code>)\nThe available balance (encrypted by <code>encrypiton_pubkey</code>)\nThe decryptable available balance\nThe decryptable available balance\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate an empty account proof data.\nCreate a withdraw proof data.\nCreate a transfer proof data that is split into equality, …\nCreate a transfer proof data.\nCreate a transfer with fee proof data\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate the <code>EmptyAccount</code> instruction account information …\nCreate the <code>ApplyPendingBalance</code> instruction account …\nCreate the <code>ApplyPendingBalance</code> instruction account …\nCreate the <code>Transfer</code> instruction account information from …\nUpdate the decryptable available balance.\nUpdate the decryptable available balance.\nUpdate the decryptable available balance.\nReturn the pending balance credit counter of the account.\nThe ElGamal ciphertext decryption handle pertaining to the …\nThe proof context information needed to process a [Transfer…\nThe transfer public keys associated with a transfer.\nThe proof context information needed to process a [Transfer…\nThe transfer public keys associated with a transfer with …\nAuditor ElGamal public key\nAuditor ElGamal public key\nCiphertext containing the high 32 bits of the transafer …\nGroup encryption of the high 48 bits of the transfer amount\nCiphertext containing the low 16 bits of the transafer …\nGroup encryption of the low 16 bits of the transfer amount\nDestination ElGamal public key\nDestination ElGamal public key\nThe transfer fee encryption of the hi 32 bits of the …\nThe transfer fee encryption of the low 16 bits of the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe ElGamal decryption handle pertaining to the low 32 …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe ElGamal decryption handle pertaining to the low 16 …\nThe new source available balance ciphertext\nThe final spendable ciphertext after the transfer,\nSource ElGamal public key\nSource ElGamal public key\nExtract the transfer amount ciphertext encrypted under the …\nThe transfer public keys associated with a transfer\nThe public encryption keys associated with the transfer: …\nCreate a transfer proof context information needed to …\nCreate a transfer proof context information needed to …\nWithdraw withheld authority public key\nApplies the pending balance to the available balance, …\nData expected by …\nApproves a token account for confidential transfers.\nThe instruction data that is needed for the …\nThe context data needed to verify a range-proof for a …\nThe instruction data that is needed for the …\nThe instruction data that is needed for the …\nThe instruction data that is needed for the …\nThe context data needed to verify a ciphertext-ciphertext …\nThe instruction data that is needed for the …\nThe context data needed to verify a ciphertext-commitment …\nThe instruction data that is needed for the …\nClose a zero-knowledge proof context state.\nAccounts needed if <code>close_split_context_state_on_execution</code> …\nConfidential Transfer extension instructions\nConfigures confidential transfers for a token account.\nData expected by …\nPubkeys associated with a context state account to be used …\nDeposit SPL Tokens into the pending balance of a …\nData expected by <code>ConfidentialTransferInstruction::Deposit</code>\nConfigure a confidential extension account to reject any …\nConfigure an account with the confidential extension to …\nEmpty the available balance in a confidential token …\nData expected by …\nConfigure a confidential extension account to accept …\nConfigure an account with the confidential extension to …\nThe context data needed to verify a pubkey validity proof.\nThe instruction data that is needed for the …\nThe instruction data that is needed for the …\nInitializes confidential transfers for a mint.\nData expected by …\nMarker trait for “plain old data”.\nDerive the <code>Pod</code> trait for a struct\nThe proof context account state\nThe instruction data that is needed for the …\nThe context data needed to verify a pubkey validity proof.\nThe context data needed to verify a range-proof for a …\nThe instruction data that is needed for the …\nTransfer tokens confidentially.\nThe instruction data that is needed for the …\nData expected by <code>ConfidentialTransferInstruction::Transfer</code>\nThe context data needed to verify a transfer proof.\nType for split transfer (without fee) instruction proof …\nThe instruction data that is needed for the …\nThe context data needed to verify a transfer-with-fee …\nType for split transfer (with fee) instruction proof …\nTransfer tokens confidentially with zero-knowledge proofs …\nData expected by …\nEmpty proof type used to distinguish if a proof context …\nUpdates the confidential transfer mint configuration for a …\nData expected by …\nVerify a batched grouped-ciphertext validity proof.\nVerify 128-bit batched range proof.\nVerify 256-bit batched range proof.\nVerify a 64-bit batched range proof.\nVerify a ciphertext-ciphertext equality proof.\nVerify a ciphertext-commitment equality proof.\nVerify a fee sigma proof.\nVerify a grouped-ciphertext validity proof.\nVerify a public key validity zero-knowledge proof.\nVerify a 64-bit range proof.\nVerify a transfer zero-knowledge proof.\nVerify a transfer with fee zero-knowledge proof.\nVerify a withdraw zero-knowledge proof.\nVerify a zero-balance proof.\nWithdraw SPL Tokens from the available balance of a …\nThe instruction data that is needed for the …\nData expected by <code>ConfidentialTransferInstruction::Withdraw</code>\nThe context data needed to verify a withdraw proof.\nThe context data needed to verify a zero-balance proof.\nThe instruction data that is needed for the …\nThe amount of tokens to deposit\nThe amount of tokens to withdraw\nCreate a <code>ApplyPendingBalance</code> instruction\nCreate an <code>ApproveAccount</code> instruction\nNew authority to decode any transfer amount in a …\nNew authority to decode any transfer amount in a …\nAuthority to modify the <code>ConfidentialTransferMint</code> …\nThe context state accounts authority\nThe context state accounts authority\nDetermines if newly configured accounts must be approved …\nDetermines if newly configured accounts must be approved …\nThe batched grouped-ciphertext validity proof instruction.\nThe batched range proof instructions.\nThe ciphertext encrypted under the ElGamal pubkey\nThe source account available balance in encrypted form\nThe ciphertext-ciphertext equality proof instruction.\nThe ciphertext-commitment equality proof instruction.\nGroup encryption of the high 48 bits of the transfer amount\nGroup encryption of the high 48 bits of the transfer amount\nGroup encryption of the low 16 bites of the transfer amount\nGroup encryption of the low 16 bits of the transfer amount\nThe context state account address for a ciphertext …\nThe Pedersen commitment to the claimed delta fee.\nCreate a <code>CloseContextState</code> instruction.\nAccounts needed if <code>close_split_context_state_on_execution</code> …\nAccounts needed if <code>close_split_context_state_on_execution</code> …\nClose associated context states after a complete execution …\nThe Pedersen commitment\nCreate a <code>ConfigureAccount</code> instruction\nThe context data for a batched range proof\nThe context data for a batched range proof\nThe context data for a batched range proof\nThe context data for the public key validity proof\nThe context data for a range proof\nThe context data for the transfer with fee proof\nThe context data for the transfer proof\nThe context data for the withdraw proof\nThe context data for the zero-balance proof\nThe proof context authority that can close the account\nExpected number of base 10 digits to the right of the …\nExpected number of base 10 digits to the right of the …\nDecrypts transfer amount from transfer-with-fee data\nDecrypts transfer amount from transfer data\nDecrypts transfer amount from transfer-with-fee data\nThe decryptable balance (always 0) once the configure …\nThe Pedersen commitment to the real delta fee.\nCreate a <code>Deposit</code> instruction\nCreate a <code>DisableConfidentialCredits</code> instruction\nCreate a <code>DisableNonConfidentialCredits</code> instruction\nCreate a <code>EmptyAccount</code> instruction\nCreate a <code>EnableConfidentialCredits</code> instruction\nCreate a <code>EnableNonConfidentialCredits</code> instruction\nThe context state account address for an equality proof …\nThe context state account address for an equality proof …\nThe expected number of pending balance credits since the …\nThe context state account address for a fee ciphertext …\nThe Pedersen commitment to the transfer fee\nFee rate expressed as basis points of the transfer amount, …\nThe fee sigma proof instruction.\nThe context state account address for a fee sigma proof …\nThe source account available balance <em>after</em> the withdraw …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe grouped-ciphertext validity proof instruction.\nCreate a <code>InitializeMint</code> instruction\nCreate a inner <code>ApplyPendingBalance</code> instruction\nCreate a <code>ConfigureAccount</code> instruction\nCreate an inner <code>EmptyAccount</code> instruction\nCreate a inner <code>Transfer</code> instruction\nCreate a inner <code>Transfer</code> instruction with fee\nCreate a inner <code>Withdraw</code> instruction\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe lamport destination account.\nThe maximum cap for a transfer fee\nMaximum fee assessed on transfers, expressed as an amount …\nThe maximum number of despots and transfers that an …\nThe new decryptable balance if the withdrawal succeeds\nThe new decryptable balance if the pending balance is …\nThe final spendable ciphertext after the transfer,\nThe final spendable ciphertext after the transfer\nThe new source decryptable balance if the transfer succeeds\nThe new source decryptable balance if the transfer succeeds\nIf true, execute no op when an associated context state …\nNo op if an associated split proof context state account …\nNo op if an associated split proof context state account …\nThe batched range proof\nThe batched range proof\nThe batched range proof\nProof that the public key is well-formed\nThe proof that a committed value in a Pedersen commitment …\nZero-knowledge proofs for Transfer\nRange proof\nProof that the source account available balance is zero\nThe proof context data\nRelative location of the <code>ProofInstruction::ZeroBalanceProof</code>\nRelative location of the …\nRelative location of the <code>ProofInstruction::VerifyWithdraw</code> …\nRelative location of the <code>ProofInstruction::VerifyTransfer</code> …\nThe proof type for the context data\nThe ElGamal pubkey\nThe public key to be proved\nThe source account ElGamal pubkey\nThe source account ElGamal pubkey\nThe public-key validity proof instruction.\nThe range proof instruction.\nThe context state account address for a range proof needed …\nThe context state account address for a range proof needed …\nThe ElGamal decryption handle pertaining to the low and …\nCreate a <code>Transfer</code> instruction with regular (no-fee) proof\nThe context state account address for a transfer amount …\nThe public encryption keys associated with the transfer: …\nCreate a <code>Transfer</code> instruction with fee proof\nCreate a <code>TransferWithSplitProof</code> instruction with fee\nThe public encryption keys associated with the transfer: …\nCreate a <code>TransferWithSplitProof</code> instruction without fee\nInterpret a slice as a <code>ProofContextState</code>.\nCreate a <code>UpdateMint</code> instruction\nCreate a <code>VerifyBatchedRangeProofU128</code> instruction.\nCreate a <code>VerifyBatchedRangeProofU256</code> instruction.\nCreate a <code>VerifyBatchedRangeProofU64</code> instruction.\nCreate a <code>VerifyCiphertextCiphertextEquality</code> instruction.\nCreate a <code>VerifyCiphertextCommitmentEquality</code> instruction.\nCreate a <code>VerifyPubkeyValidity</code> instruction.\nCreate a <code>VerifyRangeProofU64</code> instruction.\nCreate a <code>VerifyTransfer</code> instruction.\nCreate a <code>VerifyTransferWithFee</code> instruction.\nCreate a <code>VerifyWithdraw</code> instruction.\nCreate a <code>VerifyZeroBalance</code> instruction.\nCreate a <code>Withdraw</code> instruction\nThe zero-balance proof instruction.\nThe ZK Token proof program.\nThe instruction data that is needed for the …\nThe context data needed to verify a range-proof for a …\nThe 128-bit batched range proof instruction.\nThe 256-bit batched range proof instruction.\nThe 64-bit batched range proof instruction.\nThe instruction data that is needed for the …\nThe context data for a batched range proof\nThe batched range proof\nThe instruction data that is needed for the …\nThe context data for a batched range proof\nThe batched range proof\nThe instruction data that is needed for the …\nThe context data for a batched range proof\nThe batched range proof\nThe context data needed to verify a ciphertext-ciphertext …\nThe instruction data that is needed for the …\nThe context data needed to verify a ciphertext-commitment …\nThe instruction data that is needed for the …\nThe ciphertext encrypted under the ElGamal pubkey\nThe Pedersen commitment\nThe ElGamal pubkey\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe context data needed to verify a pubkey validity proof.\nThe instruction data that is needed for the …\nThe Pedersen commitment to the claimed delta fee.\nThe Pedersen commitment to the real delta fee.\nThe Pedersen commitment to the transfer fee\nThe maximum cap for a transfer fee\nThe instruction data that is needed for the …\nThe instruction data that is needed for the …\nThe context data needed to verify a pubkey validity proof.\nThe context data for the public key validity proof\nProof that the public key is well-formed\nThe public key to be proved\nThe context data needed to verify a range-proof for a …\nThe instruction data that is needed for the …\nThe context data for a range proof\nThe proof that a committed value in a Pedersen commitment …\nThe instruction data that is needed for the …\nThe context data needed to verify a transfer proof.\nThe ElGamal public keys needed for a transfer\nThe instruction data that is needed for the …\nThe context data needed to verify a transfer-with-fee …\nThe ElGamal public keys needed for a transfer with fee\nGroup encryption of the high 48 bits of the transfer amount\nGroup encryption of the high 48 bits of the transfer amount\nGroup encryption of the low 16 bites of the transfer amount\nGroup encryption of the low 16 bits of the transfer amount\nThe context data for the transfer with fee proof\nThe context data for the transfer proof\nFee rate expressed as basis points of the transfer amount, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMaximum fee assessed on transfers, expressed as an amount …\nThe final spendable ciphertext after the transfer,\nThe final spendable ciphertext after the transfer\nZero-knowledge proofs for Transfer\nTakes in a 64-bit number <code>amount</code> and a bit length <code>bit_length</code>…\nThe public encryption keys associated with the transfer: …\nThe public encryption keys associated with the transfer: …\nThe instruction data that is needed for the …\nThe withdraw proof.\nThe context data needed to verify a withdraw proof.\nNew Pedersen commitment\nThe context data for the withdraw proof\nAssociated equality proof\nThe source account available balance <em>after</em> the withdraw …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRange proof\nThe source account ElGamal pubkey\nAssociated range proof\nThe context data needed to verify a zero-balance proof.\nThe instruction data that is needed for the …\nThe source account available balance in encrypted form\nThe context data for the zero-balance proof\nProof that the source account available balance is zero\nThe source account ElGamal pubkey\nVerifies that a deposit amount is a 48-bit number and …\nThe main logic to create the three split proof data for a …\nVerify zero-knowledge proof needed for a [ConfigureAccount]…\nVerify zero-knowledge proof needed for a [EmptyAccount] …\nVerify zero-knowledge proof needed for a [Transfer] …\nVerify zero-knowledge proof needed for a [Transfer] …\nVerify zero-knowledge proof needed for a [Withdraw] …\nConfidential transfer fee\nConfidential transfer fee extension data for mints\nElGamal ciphertext containing a transfer fee\nElGamal ciphertext containing a withheld fee in an account\nConfidential Transfer Fee extension account information …\nOptional authority to set the withdraw withheld authority …\nCheck if a confidential transfer fee account is in a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nIf <code>false</code>, the harvest of withheld tokens to mint is …\nConfidential transfer fee extension instructions\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConfidential transfer fee extension processor\nWithheld fees from accounts must be encrypted with this …\nWithheld confidential transfer fee tokens that have been …\nAmount withheld during confidential transfers, to be …\nConfidential transfer fee extension information needed to …\nReturns the argument unchanged.\nCreate withdraw withheld proof data.\nCalls <code>U::from(self)</code>.\nCreate a <code>WithheldTokensInfo</code> from an ElGamal ciphertext.\nConfidential Transfer extension instructions\nConfigure a confidential transfer fee mint to reject any …\nConfigure a confidential transfer fee mint to accept …\nPermissionless instruction to transfer all withheld …\nInitializes confidential transfer fees for a mint.\nData expected by <code>InitializeConfidentialTransferFeeConfig</code>\nTransfer all withheld tokens to an account. Signed by the …\nData expected by …\nTransfer all withheld confidential tokens in the mint to …\nData expected by …\nconfidential transfer fee authority\nCreate a <code>DisableHarvestToMint</code> instruction\nCreate an <code>EnableHarvestToMint</code> instruction\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a <code>HarvestWithheldTokensToMint</code> instruction\nCreate a <code>InitializeConfidentialTransferFeeConfig</code> …\nCreate an inner <code>WithdrawWithheldTokensFromMint</code> instruction\nCreate an inner <code>WithdrawWithheldTokensFromMint</code> instruction\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe new decryptable balance in the destination token …\nThe new decryptable balance in the destination token …\nNumber of token accounts harvested\nRelative location of the …\nRelative location of the …\nElGamal public key used to encrypt withheld fees.\nCreate a <code>WithdrawWithheldTokensFromAccounts</code> instruction\nCreate an <code>WithdrawWithheldTokensFromMint</code> instruction\nCPI Guard extension for Accounts\nDetermine if CPI Guard is enabled for this account\nReturns the argument unchanged.\nDetermine if we are in CPI\nCPI Guard extension instructions\nCalls <code>U::from(self)</code>.\nLock privileged token operations from happening via CPI\nCPI Guard extension processor\nCPI Guard extension instructions\nAllow all token operations to happen via CPI as normal.\nLock certain token operations from taking place within CPI …\nCreate a <code>Disable</code> instruction\nCreate an <code>Enable</code> instruction\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nDefault Account::state extension data for mints.\nReturns the argument unchanged.\nDefault Account state extension instructions\nCalls <code>U::from(self)</code>.\nDefault Account state extension processor\nDefault Account::state in which new Accounts should be …\nDefault Account State extension instructions\nInitialize a new mint with the default state for new …\nUpdate the default state for new Accounts. Only supported …\nUtility function for decoding a DefaultAccountState …\nReturns the argument unchanged.\nCreate an <code>Initialize</code> instruction\nCalls <code>U::from(self)</code>.\nCreate an <code>Initialize</code> instruction\nGroup member pointer extension data for mints.\nAuthority that can set the member address\nReturns the argument unchanged.\nInstructions for the GroupMemberPointer extension\nCalls <code>U::from(self)</code>.\nAccount address that holds the member\nInstruction processor for the GroupMemberPointer extension\nGroup member pointer extension instructions\nInitialize a new mint with a group member pointer\nData expected by <code>Initialize</code>\nUpdate the group member pointer address. Only supported …\nData expected by <code>Update</code>\nThe public key for the account that can update the group …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate an <code>Initialize</code> instruction\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe account address that holds the member\nThe new account address that holds the group\nCreate an <code>Update</code> instruction\nGroup pointer extension data for mints.\nAuthority that can set the group address\nReturns the argument unchanged.\nAccount address that holds the group\nInstructions for the GroupPointer extension\nCalls <code>U::from(self)</code>.\nInstruction processor for the GroupPointer extension\nGroup pointer extension instructions\nInitialize a new mint with a group pointer\nData expected by <code>Initialize</code>\nUpdate the group pointer address. Only supported for mints …\nData expected by <code>Update</code>\nThe public key for the account that can update the group …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe account address that holds the group\nThe new account address that holds the group configurations\nCreate an <code>Initialize</code> instruction\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate an <code>Update</code> instruction\nIndicates that the Account owner authority cannot be …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAnnual interest rate, expressed as basis points\nInterest-bearing extension data for mints\nUnixTimestamp expressed with an alignment-independent type\nConvert a raw amount to its UI representation using the …\nCurrent rate, since the last update\nReturns the argument unchanged.\nTimestamp of initialization, from which to base interest …\nInterest-bearing mint extension instructions\nCalls <code>U::from(self)</code>.\nTimestamp of the last update, used to calculate the total …\nAverage rate from initialization until the last time it …\nInterest-bearing mint extension processor\nAuthority that can set the interest rate and authority\nThe new average rate is the time-weighted average of the …\nTry to convert a UI representation of a token amount to …\nInitialize a new mint with interest accrual.\nData expected by <code>InterestBearing::Initialize</code>\nInteresting-bearing mint extension instructions\nUpdate the interest rate. Only supported for mints that …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate an <code>Initialize</code> instruction\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe initial interest rate\nThe public key for the account that can update the rate\nCreate an <code>UpdateRate</code> instruction\nMemo Transfer extension for Accounts\nCheck if the previous sibling instruction is a memo\nReturns the argument unchanged.\nMemo Transfer extension instructions\nCalls <code>U::from(self)</code>.\nDetermine if a memo is required for transfers into this …\nMemo Transfer extension processor\nRequire transfers into this account to be accompanied by a …\nStop requiring memos for transfers into this Account.\nRequire memos for transfers into this Account. Adds the …\nRequired Memo Transfers extension instructions\nCreate a <code>Disable</code> instruction\nCreate an <code>Enable</code> instruction\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nMetadata pointer extension data for mints.\nAuthority that can set the metadata address\nReturns the argument unchanged.\nInstructions for the MetadataPointer extension\nCalls <code>U::from(self)</code>.\nAccount address that holds the metadata\nInstruction processor for the MetadataPointer extension\nInitialize a new mint with a metadata pointer\nData expected by <code>Initialize</code>\nMetadata pointer extension instructions\nUpdate the metadata pointer address. Only supported for …\nData expected by <code>Update</code>\nThe public key for the account that can update the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate an <code>Initialize</code> instruction\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe account address that holds the metadata\nThe new account address that holds the metadata\nCreate an <code>Update</code> instruction\nClose authority extension data for mints.\nOptional authority to close the mint\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nIndicates that the tokens from this mint can’t be …\nIndicates that the tokens from this account belong to a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPermanent delegate extension data for mints.\nOptional permanent delegate for transferring or burning …\nReturns the argument unchanged.\nAttempts to get the permanent delegate from the TLV data, …\nCalls <code>U::from(self)</code>.\nProcesses a Reallocate instruction\nInstruction processor for the TokenGroup extensions …\nProcesses a InitializeGroup instruction.\nProcesses an InitializeMember instruction\nProcesses an Instruction.\nProcesses an UpdateGroupAuthority instruction\nProcesses an UpdateGroupMaxSize instruction\nInstruction processor for the TokenMetadata extension …\nProcesses an Emit instruction.\nProcesses a Initialize instruction.\nProcesses an Instruction.\nProcesses a RemoveKey instruction.\nProcesses a UpdateAuthority instruction.\nProcesses an UpdateField instruction.\nMaximum possible fee in basis points is 100%, aka 10_000 …\nTransfer fee information\nTransfer fee extension data for accounts.\nTransfer fee extension data for mints.\nCalculate the fee for the given epoch and input amount\nCalculate the transfer fee\nCalculate the fee for the given epoch and output amount\nCalculate the fee that would produce the given output\nCalculate the gross transfer amount after deducting fees\nCalculate the transfer amount that will result in a …\nCheck if the extension is in a closable state\nFirst epoch where the transfer fee takes effect\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the fee for the given epoch\nTransfer fee extension instructions\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMaximum fee assessed on transfers, expressed as an amount …\nNewer transfer fee, used if the current epoch &gt;= …\nOlder transfer fee, used if the current epoch &lt; …\nTransfer fee extension processor\nAmount of transfer collected as fees, expressed as basis …\nOptional authority to set the fee\nWithdraw from mint instructions must be signed by this key\nWithheld transfer fee tokens that have been moved to the …\nAmount withheld during transfers, to be harvested to the …\nPermissionless instruction to transfer all withheld tokens …\nInitialize the transfer fee on a new mint.\nSet transfer fee. Only supported for mints that include the\nTransfer, providing expected mint information and fees\nTransfer Fee extension instructions\nTransfer all withheld tokens to an account. Signed by the …\nTransfer all withheld tokens in the mint to an account. …\nReturns the argument unchanged.\nCreates a <code>HarvestWithheldTokensToMint</code> instruction\nCreate a <code>InitializeTransferFeeConfig</code> instruction\nCalls <code>U::from(self)</code>.\nPacks a TransferFeeInstruction into a byte buffer.\nCreates a <code>SetTransferFee</code> instruction\nCreate a <code>TransferCheckedWithFee</code> instruction\nUnpacks a byte buffer into a TransferFeeInstruction\nCreates a <code>WithdrawWithheldTokensFromAccounts</code> instruction\nCreates a <code>WithdrawWithheldTokensFromMint</code> instruction\nThe amount of tokens to transfer.\nExpected number of base 10 digits to the right of the …\nExpected fee assessed on this transfer, calculated …\nMaximum fee assessed on transfers\nMaximum fee assessed on transfers\nNumber of token accounts harvested\nAmount of transfer collected as fees, expressed as basis …\nAmount of transfer collected as fees, expressed as basis …\nPubkey that may update the fees\nWithdraw instructions must be signed by this key\nTransfer hook extension data for mints.\nIndicates that the tokens from this account belong to a …\nAuthority that can set the transfer hook program id\nReturns the argument unchanged.\nReturns the argument unchanged.\nAttempts to get the transfer hook program id from the TLV …\nInstructions for the TransferHook extension\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInstruction processor for the TransferHook extension\nProgram that authorizes the transfer\nHelper function to set the transferring flag before …\nFlag to indicate that the account is in the middle of a …\nHelper function to unset the transferring flag after a …\nInitialize a new mint with a transfer hook program.\nData expected by <code>Initialize</code>\nTransfer hook extension instructions\nUpdate the transfer hook program id. Only supported for …\nData expected by <code>Update</code>\nThe public key for the account that can update the program …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate an <code>Initialize</code> instruction\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe program id that performs logic during transfers\nThe program id that performs logic during transfers\nCreate an <code>Update</code> instruction\nThe offset of state field in Account’s C representation\nA trait for token Account structs to enable efficiently …\nCheck if the account data buffer represents an initialized …\nUnpacks an account’s mint from opaque account data.\nCall after account length has already been verified to …\nUnpacks an account’s owner from opaque account data.\nCall after account length has already been verified to …\nCall after account length has already been verified to …\nCheck if the account data is a valid token account\nOwner of a given token account\nConvert an Amount of tokens to a UiAmount <code>string</code>, using …\nApproves a delegate.  A delegate is given the authority …\nApproves a delegate.  A delegate is given the authority …\nSpecifies the authority type for SetAuthority instructions\nBurns tokens by removing them from an account.  <code>Burn</code> does …\nBurns tokens by removing them from an account.  <code>BurnChecked</code>…\nClose an account by transferring all its SOL to the …\nAuthority to close a token account\nAuthority to close a mint account\nThe common instruction prefix for Confidential Transfer …\nAuthority to set the withdraw withheld authority …\nThe common instruction prefix for the confidential …\nAuthority to update confidential transfer mint and aprove …\nThe common instruction prefix for CPI Guard account …\nCreates the native mint.\nThe common instruction prefix for Default Account State …\nFreeze an Initialized account using the Mint’s …\nAuthority to freeze any account associated with the Mint\nGets the required size of an account for the given mint as …\nAuthority to set the group member address\nThe common instruction prefix for group member pointer …\nAuthority to set the group address\nThe common instruction prefix for group pointer extension …\nInitializes a new account to hold tokens.  If this account …\nLike InitializeAccount, but the owner pubkey is passed via …\nLike InitializeAccount2, but does not require the Rent …\nInitialize the Immutable Owner extension for the given …\nInitializes a new mint and optionally deposits all the …\nLike InitializeMint, but does not require the Rent sysvar …\nInitialize the close account authority on a new mint.\nInitializes a multisignature account with N provided …\nLike InitializeMultisig, but does not require the Rent …\nInitialize the non transferable extension for the given …\nInitialize the permanent delegate on a new mint.\nThe common instruction prefix for Interest Bearing …\nAuthority to set the interest rate\nMaximum number of multisignature signers (max N)\nMinimum number of multisignature signers (min N)\nThe common instruction prefix for Memo Transfer account …\nAuthority to set the metadata address\nThe common instruction prefix for metadata pointer …\nMints new tokens to an account.  The native mint does not …\nMints new tokens to an account.  The native mint does not …\nAuthority to mint new tokens\nAuthority to transfer or burn any tokens for a mint\nCheck to see if a token account is large enough for a list …\nRevokes the delegate’s authority.\nSets a new authority of a mint or account.\nGiven a wrapped / native token account (a token account …\nThaw a Frozen account using the Mint’s freeze_authority …\nInstructions supported by the token program.\nNOTE This instruction is deprecated in favor of …\nTransfers tokens from one account to another either …\nAuthority to set the transfer fee\nThe common instruction prefix for Transfer Fee extension …\nThe common instruction prefix for transfer hook extension …\nAuthority to set the transfer hook program id\nConvert a UiAmount of tokens to a little-endian <code>u64</code> raw …\nThis instruction is to be used to rescue SOLs sent to any …\nAuthority to withdraw withheld tokens from a mint\nCreates an <code>AmountToUiAmount</code> instruction\nCreates an <code>Approve</code> instruction.\nCreates an <code>ApproveChecked</code> instruction.\nCreates a <code>Burn</code> instruction.\nCreates a <code>BurnChecked</code> instruction.\nCreates a <code>CloseAccount</code> instruction.\nCreates a <code>CreateNativeMint</code> instruction\nUtility function for decoding instruction data\nUtility function for decoding just the instruction type\nCreates a <code>FreezeAccount</code> instruction.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a <code>GetAccountDataSize</code> instruction\nCreates a <code>InitializeAccount</code> instruction.\nCreates a <code>InitializeAccount2</code> instruction.\nCreates a <code>InitializeAccount3</code> instruction.\nCreate an <code>InitializeImmutableOwner</code> instruction\nCreates a <code>InitializeMint</code> instruction.\nCreates a <code>InitializeMint2</code> instruction.\nCreates an <code>InitializeMintCloseAuthority</code> instruction\nCreates a <code>InitializeMultisig</code> instruction.\nCreates a <code>InitializeMultisig2</code> instruction.\nCreates an <code>InitializeNonTransferableMint</code> instruction\nCreates an <code>InitializePermanentDelegate</code> instruction\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nUtility function that checks index is between MIN_SIGNERS …\nCreates a <code>MintTo</code> instruction.\nCreates a <code>MintToChecked</code> instruction.\nPacks a TokenInstruction into a byte buffer.\nCreates a <code>Reallocate</code> instruction\nCreates a <code>Revoke</code> instruction.\nCreates a <code>SetAuthority</code> instruction.\nCreates a <code>SyncNative</code> instruction\nCreates a <code>ThawAccount</code> instruction.\nCreates a <code>Transfer</code> instruction.\nCreates a <code>TransferChecked</code> instruction.\nCreates a <code>UiAmountToAmount</code> instruction\nUnpacks a byte buffer into a TokenInstruction.\nCreates a <code>WithdrawExcessLamports</code> Instruction\nThe amount of tokens to transfer.\nThe amount of tokens the delegate is approved for.\nThe amount of new tokens to mint.\nThe amount of tokens to burn.\nThe amount of tokens to transfer.\nThe amount of tokens the delegate is approved for.\nThe amount of new tokens to mint.\nThe amount of tokens to burn.\nThe amount of tokens to convert.\nThe type of authority to update.\nAuthority that must sign the <code>CloseAccount</code> instruction on a …\nNumber of base 10 digits to the right of the decimal place.\nExpected number of base 10 digits to the right of the …\nExpected number of base 10 digits to the right of the …\nExpected number of base 10 digits to the right of the …\nExpected number of base 10 digits to the right of the …\nNumber of base 10 digits to the right of the decimal place.\nAuthority that may sign for <code>Transfer</code>s and <code>Burn</code>s on any …\nAdditional extension types to include in the returned …\nNew extension types to include in the reallocated account\nThe freeze authority/multisignature of the mint.\nThe freeze authority/multisignature of the mint.\nThe number of signers (M) required to validate this …\nThe number of signers (M) required to validate this …\nThe authority/multisignature to mint tokens.\nThe authority/multisignature to mint tokens.\nThe new authority\nThe new account’s owner/multisignature.\nThe new account’s owner/multisignature.\nThe ui_amount of tokens to convert.\nThere are 10^9 lamports in one SOL\nThe const program ID.\nSeed for the native_mint’s program-derived address\nReturns <code>true</code> if given pubkey is the program ID.\nReturns the program ID.\nType representing the output of an account fetching …\nGeneric error type that can come out of any client while …\nContains the error value\nContains the success value\nOffchain helper to get all additional required account …\nHelper to CPI into token-2022 on-chain, looking through …\nProgram state handler.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nProcesses an Instruction.\nProcesses an AmountToUiAmount instruction\nProcesses an Approve instruction.\nProcesses a Burn instruction.\nProcesses a CloseAccount instruction.\nProcesses a CreateNativeMint instruction\nProcesses a GetAccountDataSize instruction\nProcesses an InitializeAccount instruction.\nProcesses an InitializeAccount2 instruction.\nProcesses an InitializeAccount3 instruction.\nProcesses an InitializeImmutableOwner instruction\nProcesses an InitializeMint instruction.\nProcesses an InitializeMint2 instruction.\nProcesses an InitializeMintCloseAuthority instruction\nProcesses a InitializeMultisig instruction.\nProcesses a InitializeMultisig2 instruction.\nProcesses an InitializeNonTransferableMint instruction\nProcesses an InitializePermanentDelegate instruction\nProcesses a MintTo instruction.\nProcesses an Revoke instruction.\nProcesses a SetAuthority instruction.\nProcesses a SyncNative instruction\nProcesses a FreezeAccount or a ThawAccount instruction.\nProcesses a Transfer instruction.\nProcesses an AmountToUiAmount instruction\nWithdraw Excess Lamports is used to recover Lamports …\nValidates owner(s) are present. Used for Mints and …\nThe proof is pre-verified into a context state account.\nThe proof is included in the same transaction of a …\nA proof location type meant to be used for arguments to …\nInstruction options for when using split context state …\nClose associated context states after a complete execution …\nDecodes the proof context data associated with a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIf true, execute no op when an associated split proof …\nAccount data.\nAccount state.\nAccount has been frozen by the mint freeze authority. …\nAccount is initialized; the account owner and/or delegate …\nMint data.\nMultisignature data.\nAccount is not yet initialized\nThe amount of tokens this account holds.\nOptional authority to close the account.\nNumber of base 10 digits to the right of the decimal place.\nIf <code>delegate</code> is <code>Some</code> then <code>delegated_amount</code> represents the …\nThe amount delegated\nOptional authority to freeze token accounts.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks if account is frozen\nIs <code>true</code> if this structure has been initialized\nIs <code>true</code> if this structure has been initialized\nChecks if account is native\nIf is_some, this is a native token, and the value logs the …\nChecks if a token Account’s owner is the system_program …\nNumber of signers required\nThe mint associated with this account\nOptional authority used to mint new tokens. The mint …\nNumber of valid signers\nThe owner of this account.\nSigner public keys\nThe account’s state\nTotal supply of tokens.")