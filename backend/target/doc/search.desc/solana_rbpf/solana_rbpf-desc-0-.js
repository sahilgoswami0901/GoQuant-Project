searchState.loadedDescShard("solana_rbpf", 0, "Virtual machine and JIT compiler for eBPF programs.\nAligned memory\nThis module translates eBPF assembly language to binary.\nGenerates an adapter for a BuiltinFunction between the …\nFunctions in this module are used to handle eBPF programs …\nThis module contains all the definitions related to eBPF, …\nThis module relocates a BPF ELF\nDependency-less 64 bit ELF parser\nInternal ELF parser abstraction.\nThis module contains all the definitions related to eBPF, …\nThis module defines memory regions\nModule provides API to create eBPF programs by Rust …\nInterpreter for eBPF programs.\nThis module defines memory regions\nCommon interface for built-in and user supplied programs\nStatic Byte Code Analysis\nThis module implements some built-in syscalls that can be …\nThis “verifier” performs simple checks when the eBPF …\nVirtual machine for eBPF programs.\nProvides u8 slices at a specified alignment\nScalar types, aka “plain old data”\nGet an aligned slice\nGet an aligned mutable slice\nGrows memory with <code>value</code> repeated <code>num</code> times starting at the …\nReturns the argument unchanged.\nReturns a filled AlignedMemory by copying the given slice\nCalls <code>U::from(self)</code>.\nIs the memory empty\nReturns true if <code>ptr</code> is aligned to <code>align</code>.\nGet the length of the data\nCalculate memory size\nReturns a new empty AlignedMemory with uninitialized …\nReturns a new empty AlignedMemory with zero initialized …\nWrite a slice of bytes into the memory.\nGet the current write index\nWrite a generic type T into the memory.\nReturns a new filled AlignedMemory with zero initialized …\nParse assembly source and translate to binary.\nDisassemble an eBPF instruction\nBPF opcode: <code>add32 dst, imm</code> /// <code>dst += imm</code>.\nBPF opcode: <code>add32 dst, src</code> /// <code>dst += src</code>.\nBPF opcode: <code>add64 dst, imm</code> /// <code>dst += imm</code>.\nBPF opcode: <code>add64 dst, src</code> /// <code>dst += src</code>.\nBPF opcode: <code>and32 dst, imm</code> /// <code>dst &amp;= imm</code>.\nBPF opcode: <code>and32 dst, src</code> /// <code>dst &amp;= src</code>.\nBPF opcode: <code>and64 dst, imm</code> /// <code>dst &amp;= imm</code>.\nBPF opcode: <code>and64 dst, src</code> /// <code>dst &amp;= src</code>.\nBPF opcode: <code>arsh32 dst, imm</code> /// <code>dst &gt;&gt;= imm (arithmetic)</code>.\nBPF opcode: <code>arsh32 dst, src</code> /// <code>dst &gt;&gt;= src (arithmetic)</code>.\nBPF opcode: <code>arsh64 dst, imm</code> /// <code>dst &gt;&gt;= imm (arithmetic)</code>.\nBPF opcode: <code>arsh64 dst, src</code> /// <code>dst &gt;&gt;= src (arithmetic)</code>.\nBPF opcode: <code>be dst</code> /// …\nBPF mode modifier: absolute load.\nBPF ALU/ALU64 operation code: addition.\nBPF operation class: 32 bits arithmetic operation.\nBPF operation class: 64 bits arithmetic operation.\nMask to extract the arithmetic operation code from an …\nBPF ALU/ALU64 operation code: and.\nBPF ALU/ALU64 operation code: sign extending right shift.\nBPF size modifier: byte (1 byte).\nBPF JMP operation code: syscall function call.\nMask to extract the operation class from an operation code.\nBPF ALU/ALU64 operation code: division. [DEPRECATED]\nBPF size modifier: double word (8 bytes).\nBPF ALU/ALU64 operation code: endianness conversion.\nBPF JMP operation code: return from program.\nBPF size modifier: half-word (2 bytes).\nBPF ALU/ALU64 operation code: high or.\nBPF mode modifier: immediate value.\nBPF mode modifier: indirect load.\nBPF JMP operation code: jump.\nBPF JMP operation code: jump if equal.\nBPF JMP operation code: jump if greater or equal.\nBPF JMP operation code: jump if greater than.\nBPF JMP operation code: jump if lower or equal.\nBPF JMP operation code: jump if lower than.\nBPF operation class: jump.\nBPF JMP operation code: jump if not equal.\nBPF JMP operation code: jump if <code>src</code> &amp; <code>reg</code>.\nBPF JMP operation code: jump if greater or equal (signed).\nBPF JMP operation code: jump if greater than (signed).\nBPF JMP operation code: jump if lower or equal (signed).\nBPF JMP operation code: jump if lower than (signed).\nBPF source operand modifier: 32-bit immediate value.\nBPF operation class: load from immediate. [DEPRECATED]\nBPF operation class: load from register.\nBPF PQR operation code: low multiplication.\nBPF ALU/ALU64 operation code: left shift.\nBPF mode modifier: load from / store to memory.\nBPF ALU/ALU64 operation code: modulus. [DEPRECATED]\nBPF ALU/ALU64 operation code: move.\nBPF ALU/ALU64 operation code: multiplication. [DEPRECATED]\nBPF ALU/ALU64 operation code: negation. [DEPRECATED]\nBPF ALU/ALU64 operation code: or.\nBPF operation class: product / quotient / remainder.\nBPF ALU/ALU64 operation code: right shift.\nBPF PQR operation code: signed division quotient.\nBPF PQR operation code: signed high multiplication.\nBPF PQR operation code: signed division remainder.\nBPF operation class: store immediate.\nBPF operation class: store value from register.\nBPF ALU/ALU64 operation code: subtraction.\nBPF PQR operation code: unsigned division quotient.\nBPF PQR operation code: unsigned high multiplication.\nBPF PQR operation code: unsigned division remainder.\nBPF size modifier: word (4 bytes).\nBPF source operand modifier: <code>src</code> register.\nBPF ALU/ALU64 operation code: exclusive or.\nBPF opcode: <code>call imm</code> /// syscall function call to syscall …\nBPF opcode: tail call.\nBPF opcode: <code>div32 dst, imm</code> /// <code>dst /= imm</code>.\nBPF opcode: <code>div32 dst, src</code> /// <code>dst /= src</code>.\nBPF opcode: <code>div64 dst, imm</code> /// <code>dst /= imm</code>.\nBPF opcode: <code>div64 dst, src</code> /// <code>dst /= src</code>.\nSolana BPF version flag\nBPF opcode: <code>exit</code> /// <code>return r0</code>.\nFirst scratch register\nFrame pointer register\nBPF opcode: <code>hor64 dst, imm</code> /// <code>dst |= imm &lt;&lt; 32</code>.\nAlignment of the memory regions in host address space in …\nSize of an eBPF instructions, in bytes.\nAn eBPF instruction.\nBPF opcode: <code>ja +off</code> /// <code>PC += off</code>.\nBPF opcode: <code>jeq dst, imm, +off</code> /// <code>PC += off if dst == imm</code>.\nBPF opcode: <code>jeq dst, src, +off</code> /// <code>PC += off if dst == src</code>.\nBPF opcode: <code>jge dst, imm, +off</code> /// <code>PC += off if dst &gt;= imm</code>.\nBPF opcode: <code>jge dst, src, +off</code> /// <code>PC += off if dst &gt;= src</code>.\nBPF opcode: <code>jgt dst, imm, +off</code> /// <code>PC += off if dst &gt; imm</code>.\nBPF opcode: <code>jgt dst, src, +off</code> /// <code>PC += off if dst &gt; src</code>.\nBPF opcode: <code>jle dst, imm, +off</code> /// <code>PC += off if dst &lt;= imm</code>.\nBPF opcode: <code>jle dst, src, +off</code> /// <code>PC += off if dst &lt;= src</code>.\nBPF opcode: <code>jlt dst, imm, +off</code> /// <code>PC += off if dst &lt; imm</code>.\nBPF opcode: <code>jlt dst, src, +off</code> /// <code>PC += off if dst &lt; src</code>.\nBPF opcode: <code>jne dst, imm, +off</code> /// <code>PC += off if dst != imm</code>.\nBPF opcode: <code>jne dst, src, +off</code> /// <code>PC += off if dst != src</code>.\nBPF opcode: <code>jset dst, imm, +off</code> /// <code>PC += off if dst &amp; imm</code>.\nBPF opcode: <code>jset dst, src, +off</code> /// <code>PC += off if dst &amp; src</code>.\nBPF opcode: <code>jsge dst, imm, +off</code> /// …\nBPF opcode: <code>jsge dst, src, +off</code> /// …\nBPF opcode: <code>jsgt dst, imm, +off</code> /// …\nBPF opcode: <code>jsgt dst, src, +off</code> /// …\nBPF opcode: <code>jsle dst, imm, +off</code> /// …\nBPF opcode: <code>jsle dst, src, +off</code> /// …\nBPF opcode: <code>jslt dst, imm, +off</code> /// …\nBPF opcode: <code>jslt dst, src, +off</code> /// …\nBPF opcode: <code>ldxb dst, [src + off]</code> /// …\nBPF opcode: <code>lddw dst, imm</code> /// <code>dst = imm</code>. [DEPRECATED]\nBPF opcode: <code>ldxdw dst, [src + off]</code> /// …\nBPF opcode: <code>ldxh dst, [src + off]</code> /// …\nBPF opcode: <code>ldxw dst, [src + off]</code> /// …\nBPF opcode: <code>le dst</code> /// …\nBPF opcode: <code>lmul32 dst, imm</code> /// <code>dst *= (dst * imm) as u32</code>.\nBPF opcode: <code>lmul32 dst, src</code> /// <code>dst *= (dst * src) as u32</code>.\nBPF opcode: <code>lmul64 dst, imm</code> /// <code>dst = (dst * imm) as u64</code>.\nBPF opcode: <code>lmul64 dst, src</code> /// <code>dst = (dst * src) as u64</code>.\nBPF opcode: <code>lsh32 dst, imm</code> /// <code>dst &lt;&lt;= imm</code>.\nBPF opcode: <code>lsh32 dst, src</code> /// <code>dst &lt;&lt;= src</code>.\nBPF opcode: <code>lsh64 dst, imm</code> /// <code>dst &lt;&lt;= imm</code>.\nBPF opcode: <code>lsh64 dst, src</code> /// <code>dst &lt;&lt;= src</code>.\nStart of the heap in the memory map\nStart of the input buffers in the memory map\nStart of the program bits (text and ro segments) in the …\nStart of the stack in the memory map\nBPF opcode: <code>mod32 dst, imm</code> /// <code>dst %= imm</code>.\nBPF opcode: <code>mod32 dst, src</code> /// <code>dst %= src</code>.\nBPF opcode: <code>mod64 dst, imm</code> /// <code>dst %= imm</code>.\nBPF opcode: <code>mod64 dst, src</code> /// <code>dst %= src</code>.\nBPF opcode: <code>mov32 dst, imm</code> /// <code>dst = imm</code>.\nBPF opcode: <code>mov32 dst, src</code> /// <code>dst = src</code>.\nBPF opcode: <code>mov64 dst, imm</code> /// <code>dst = imm</code>.\nBPF opcode: <code>mov64 dst, src</code> /// <code>dst = src</code>.\nBPF opcode: <code>mul32 dst, imm</code> /// <code>dst *= imm</code>.\nBPF opcode: <code>mul32 dst, src</code> /// <code>dst *= src</code>.\nBPF opcode: <code>div64 dst, imm</code> /// <code>dst /= imm</code>.\nBPF opcode: <code>div64 dst, src</code> /// <code>dst /= src</code>.\nBPF opcode: <code>neg32 dst</code> /// <code>dst = -dst</code>.\nBPF opcode: <code>neg64 dst, imm</code> /// <code>dst = -dst</code>.\nBPF opcode: <code>or32 dst, imm</code> /// <code>dst |= imm</code>.\nBPF opcode: <code>or32 dst, src</code> /// <code>dst |= src</code>.\nBPF opcode: <code>or64 dst, imm</code> /// <code>dst |= imm</code>.\nBPF opcode: <code>or64 dst, src</code> /// <code>dst |= src</code>.\nMaximum number of instructions in an eBPF program.\nBPF opcode: <code>rsh32 dst, imm</code> /// <code>dst &gt;&gt;= imm</code>.\nBPF opcode: <code>rsh32 dst, src</code> /// <code>dst &gt;&gt;= src</code>.\nBPF opcode: <code>rsh64 dst, imm</code> /// <code>dst &gt;&gt;= imm</code>.\nBPF opcode: <code>rsh64 dst, src</code> /// <code>dst &gt;&gt;= src</code>.\nNumber of scratch registers\nBPF opcode: <code>shmul32 dst, imm</code> /// <code>dst = (dst * imm) as i64</code>. …\nBPF opcode: <code>sdiv32 dst, src</code> /// <code>dst /= src</code>.\nBPF opcode: <code>sdiv64 dst, imm</code> /// <code>dst /= imm</code>.\nBPF opcode: <code>sdiv64 dst, src</code> /// <code>dst /= src</code>.\nBPF opcode: <code>shmul64 dst, imm</code> /// <code>dst = (dst * imm) &gt;&gt; 64</code>.\nBPF opcode: <code>shmul64 dst, src</code> /// <code>dst = (dst * src) &gt;&gt; 64</code>.\nBPF opcode: <code>srem32 dst, imm</code> /// <code>dst %= imm</code>.\nBPF opcode: <code>srem32 dst, src</code> /// <code>dst %= src</code>.\nBPF opcode: <code>srem64 dst, imm</code> /// <code>dst %= imm</code>.\nBPF opcode: <code>srem64 dst, src</code> /// <code>dst %= src</code>.\nStack pointer register\nBPF opcode: <code>stb [dst + off], imm</code> /// …\nBPF opcode: <code>stxb [dst + off], src</code> /// …\nBPF opcode: <code>stdw [dst + off], imm</code> /// …\nBPF opcode: <code>stxdw [dst + off], src</code> /// …\nBPF opcode: <code>sth [dst + off], imm</code> /// …\nBPF opcode: <code>stxh [dst + off], src</code> /// …\nBPF opcode: <code>stw [dst + off], imm</code> /// …\nBPF opcode: <code>stxw [dst + off], src</code> /// …\nBPF opcode: <code>sub32 dst, imm</code> /// <code>dst = imm - dst</code>.\nBPF opcode: <code>sub32 dst, src</code> /// <code>dst -= src</code>.\nBPF opcode: <code>sub64 dst, imm</code> /// <code>dst -= imm</code>.\nBPF opcode: <code>sub64 dst, src</code> /// <code>dst -= src</code>.\nBPF opcode: <code>uhmul32 dst, imm</code> /// <code>dst = (dst * imm) as u64</code>. …\nBPF opcode: <code>udiv32 dst, src</code> /// <code>dst /= src</code>.\nBPF opcode: <code>udiv64 dst, imm</code> /// <code>dst /= imm</code>.\nBPF opcode: <code>udiv64 dst, src</code> /// <code>dst /= src</code>.\nBPF opcode: <code>uhmul64 dst, imm</code> /// <code>dst = (dst * imm) &gt;&gt; 64</code>.\nBPF opcode: <code>uhmul64 dst, src</code> /// <code>dst = (dst * src) &gt;&gt; 64</code>.\nBPF opcode: <code>urem32 dst, imm</code> /// <code>dst %= imm</code>.\nBPF opcode: <code>urem32 dst, src</code> /// <code>dst %= src</code>.\nBPF opcode: <code>urem64 dst, imm</code> /// <code>dst %= imm</code>.\nBPF opcode: <code>urem64 dst, src</code> /// <code>dst %= src</code>.\nUpper half of a pointer is the region index, lower half …\nBPF opcode: <code>xor32 dst, imm</code> /// <code>dst ^= imm</code>.\nBPF opcode: <code>xor32 dst, src</code> /// <code>dst ^= src</code>.\nBPF opcode: <code>xor64 dst, imm</code> /// <code>dst ^= imm</code>.\nBPF opcode: <code>xor64 dst, src</code> /// <code>dst ^= src</code>.\nMerge the two halves of a LD_DW_IMM instruction\nDestination register operand.\nReturns the argument unchanged.\nGet the instruction at <code>idx</code> of an eBPF program. <code>idx</code> is the …\nSame as <code>get_insn</code> except not checked\nHash a symbol name\nImmediate value operand.\nCalls <code>U::from(self)</code>.\nOffset operand.\nOperation code.\nInstruction pointer.\nSource register operand.\nTurn an <code>Insn</code> back into an array of bytes.\nTurn an <code>Insn</code> into an vector of bytes.\nRelocation failed, no loadable section contains virtual …\nError definitions\nEntrypoint out of bounds\nElf loader/relocator\nFailed to get section\nFailed to parse ELF file\nFailed to read relocation info\nInvaid entrypoint\nInvalid program header\nRelocation failed, invalid referenced virtual address\nNot one text section\nRelative jump out of bounds\nSection not found\nSymbol hash collision\nRelocation failed, unknown type\nUnknown symbol\nUnresolved symbol\nDetected sbpf_version required by the executable which are …\nOffset or value is out of bounds\nRead-write data not supported\nIncompatible ELF: wrong ABI\nIncompatible ELF: wrong class\nIncompatible ELF: wrong endianess\nIncompatible ELF: wrong mchine\nIncompatible ELF: wrong type\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates an executable from an ELF file\nCreates an executable from machine code\nGet the configuration settings\nGet the entry point offset into the text section\nGet the function registry\nGet the loader built-in program\nGet a memory region that can be used to access the merged …\nGet the concatenated read-only sections (including the …\nGet the executable sbpf_version\nGet the .text section virtual address and bytes\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nFully loads an ELF, including validation and relocation\nCalculate the total memory size of the executable\nCreate from raw text section bytes (list of instructions)\nValidates the ELF\nVerify the executable\nThe parsed structure of an ELF file\nError definitions\nInvalid alignment\nInvalid .dynamic section table\nELF file header is inconsistent or unsupported\nProgram header is inconsistent or unsupported\nInvalid relocation table\nSection header is inconsistent or unsupported\nThe size isn’t valid\nSection or symbol name is not UTF8 or too long\nNo dynamic string table\nNo section name string table present in the file\nNo string table\nAn index or memory range does exeed its boundaries\nHeaders, tables or sections do overlap in the file\nMaximum length of section name allowed.\nSections are not sorted in ascending order\nSection or symbol name is too long\nReturns the dynamic relocations table.\nReturns the name of the <code>st_name</code> dynamic symbol\nReturns the dynamic symbol table.\nReturns the file header.\nReturns the argument unchanged.\nReturns the argument unchanged.\nQuery a single string from a section which is marked as …\nReturns the symbol table of a section which is marked as …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nParse from the given byte slice\nReturns the program header table.\nReturns the section header table.\nReturns the string corresponding to the given <code>sh_name</code>\nReturns the <code>&amp;[T]</code> contained in the data described by the …\nReturns the <code>&amp;[T]</code> contained in the section data described …\nReturns the name of the <code>st_name</code> symbol\nReturns the symbol table\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe common trait implemented by LegacyParser and NewParser.\nELF program header.\nELF relocation.\nELF section header.\nELF symbol.\nThe Goblin based ELF parser.\nThe new ELF parser.\nProgram header type.\nIterator of program headers.\nRelocation type.\nIterator of relocations.\nSection header type.\nIterator of section headers\nSymbol type.\nIterator of symbols.\nReturns the dynamic relocations.\nReturns the symbols included in the dynamic symbol table.\nReturns the dynamic symbol name at the given <code>st_name</code> …\nReturns the byte range the section spans in the file.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the file header.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns whether the symbol is a function.\nReturns whether the section is writable.\nReturns the segment size when loaded in memory.\nReturns the segment file offset.\nReturns the segment virtual address.\nParses the ELF data included in the buffer.\nReturns the program headers.\nReturns the offset where to apply the relocation.\nReturns the symbol index.\nReturns the relocation type.\nReturns the section with the given <code>name</code>.\nReturns the section headers.\nReturns the section name at the given <code>sh_name</code> offset.\nReturns the section virtual address.\nReturns the section flags.\nReturns the section name offset.\nReturns the section file offset.\nReturns the section size.\nReturns the section type.\nReturns the symbol type and binding attributes.\nReturns the symbol name offset.\nReturns the value associated with the symbol.\nReturns the symbol name at the given <code>st_name</code> offset.\nReturns the symbols included in the symbol table.\nReturns the segment virtual address range.\nReturns the virtual address range.\nAccess violation (general)\nExceeded max BPF to BPF call depth\nAttempt to call to an address outside the text segment\nDivide by zero“\nDivide overflow\nError definitions\nELF error\nFailure\nFailure\nExceeded max instructions allowed\nExceeded max instructions allowed\nCompilation is too big to fit\nAttempt to exit from root call frame\nFunction was already registered\nInvalid instruction\nMemory region index or virtual address space is invalid\nInvalid virtual address\nProgram has not been JIT-compiled\nLibc function call returned an error\nSuccess\nSuccess\nReturn value of programs and syscalls\nSame as <code>Result</code> but provides a stable memory layout\nAccess violation (stack specific)\nSyscall error\nUnsupported instruction\nVerifier error\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>true</code> if <code>Err</code>\n<code>true</code> if <code>Ok</code>\nMaps ok values, leaving error values untouched\nMaps error values, leaving ok values untouched\nReturns the inner value if <code>Ok</code>, panics otherwise\nReturns the inner error if <code>Err</code>, panics otherwise\nfuzzing utility function\nAbsolute or unconditional\nArchitecture of instructions\nBig endian\nJump if <code>src</code> &amp; <code>dst</code>\nBPF instruction stack in byte representation\n8-bit size\ntype of targeted transformation\nConditions for JMP instructions\n64-bit size\nBytes endian\nJump if <code>==</code>\nstruct representation of EXIT instruction\nstruct representation of CALL instruction\nJump if <code>&gt;</code>\nJump if <code>&gt;=</code>\nJump if <code>&gt;=</code> (signed)\nJump if <code>&gt;</code> (signed)\n16-bit size\nimmediate field will be used as a source\nRepresents single eBPF instruction\nGeneral trait for <code>Instruction</code>s and <code>BpfCode</code>. Provides …\nstruct representation of JMP instructions\nLittle endian\nstruct representation of LOAD instructions\nJump if <code>&lt;</code>\nJump if <code>&lt;=</code>\nJump if <code>&lt;=</code> (signed)\nJump if <code>&lt;</code> (signed)\nMemory size for LOAD and STORE instructions\nstruct to represent <code>MOV ALU</code> instructions\nJump if <code>!=</code>\nsrc register will be used as a source\nThe source of ALU and JMP instructions\nstruct representation of STORE instructions\nstruct representation of byte swap operation\n32-bit size\n32-bit instructions\n64-bit instructions\ncreate ADD instruction\ncreate AND instruction\ncreate OR instruction\ncreate XOR instruction\ncreate CALL instruction\ncreate DIV instruction\ncreate EXIT instruction\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nreturns destination register\nreturns immediate value\nget <code>ebpf::Insn</code> struct\nget mutable <code>ebpf::Insn</code> struct\nreturns offset bytes\nreturns source register\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nconsume <code>Self</code> with transformation into <code>Self::Bytes</code>\nreturns <code>BpfCode</code> instruction stack as <code>&amp;[u8]</code>\ncreate conditional JMP instruction\ncreate unconditional JMP instruction\ncreate LSHIFT instruction\ncreate LOAD instruction, IMMEDIATE is the source\ncreate ABSOLUTE LOAD instruction\ncreate INDIRECT LOAD instruction\ncreate LOAD instruction, MEMORY is the source\ncreate MOD instruction\ncreate MOV instruction\ncreate MUL instruction\ncreate NEGATE instruction\ncreates new empty BPF instruction stack\nreturns instruction opt code\npush MOV instruction into BpfCode instruction stack\npush bytes swap instruction into BpfCode instruction stack\npush LOAD instruction into BpfCode instruction stack\npush STORE instruction into BpfCode instruction stack\npush JMP instruction into BpfCode instruction stack\npush CALL instruction into BpfCode instruction stack\npush EXIT instruction into BpfCode instruction stack\ncreate RSHIFT instruction\nsets destination register\nsets immediate value\nsets offset bytes\nsets source register\ncreate SIGNED RSHIFT instruction\ncreates STORE instruction, IMMEDIATE is the source\ncreates STORE instruction, MEMORY is the source\ncreate SUB instruction\ncreate byte swap instruction\nState of an interpreter\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreates a new interpreter state\nGeneral purpose registers and pc\nAdvances the interpreter state by one instruction\nType of memory access\nAligned memory mapping which uses the upper half of an …\nMemory mapping that uses the upper half of an address to …\nThe memory region is writable but must be copied before …\nUsed when address translation is disabled\nRead\nCallback executed when a CoW memory region is written to\nMaps virtual memory to host memory.\nMemory region for bounds checking and address translation\nThe state of a memory region.\nThe memory region is readable\nWrite\nMemory mapping that allows mapping unaligned memory …\nMemory mapping based on eytzinger search.\nThe memory region is writable\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the <code>MemoryRegion</code>s in this mapping\nReturns the <code>MemoryRegion</code>s in this mapping\nReturns the <code>MemoryRegion</code>s in this mapping.\nstart host address\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLength in bytes\nLoads <code>size_of::&lt;T&gt;()</code> bytes from the given address.\nLoads <code>size_of::&lt;T&gt;()</code> bytes from the given address.\nLoads <code>size_of::&lt;T&gt;()</code> bytes from the given address.\nGiven a list of regions translate from virtual machine to …\nGiven a list of regions translate from virtual machine to …\nMap virtual memory to host memory.\nCreates a new UnalignedMemoryMapping structure from the …\nCreates a new MemoryMapping structure from the given …\nCreates a new memory mapping.\nCreates a new copy on write MemoryRegion.\nOnly to be used in tests and benches\nCreates a new readonly MemoryRegion from a slice\nCreates a new UnalignedMemoryMapping from the given …\nCreates a new MemoryMapping structure from the given …\nCreates a new memory mapping.\nCreates a new writable MemoryRegion from a mutable slice\nCreates a new writable gapped MemoryRegion from a mutable …\nReturns the <code>MemoryRegion</code> corresponding to the given …\nReturns the <code>MemoryRegion</code> corresponding to the given …\nReturns the <code>MemoryRegion</code> corresponding to the given …\nReplaces the <code>MemoryRegion</code> at the given index\nReplaces the <code>MemoryRegion</code> at the given index\nReplaces the <code>MemoryRegion</code> at the given index\nWhether the region is readonly, writable or must be copied …\nStore <code>value</code> at the given address.\nStore <code>value</code> at the given address.\nStore <code>value</code> at the given address.\nstart virtual address\nend virtual address\nSize of regular gaps as bit shift (63 means this region is …\nConvert a virtual machine address into a host address\nSyscall function without context\nRepresents the interface to a fixed functionality program\nHolds the function symbols of an Executable\nDefines a set of sbpf_version of an executable\nThe legacy format\nThe current format\nThe future format with BTF support\nUse src reg instead of imm in callx\nDisable the only two slots long instruction: LD_DW_IMM\nUse dynamic stack frame sizes\nAllow sh_addr != sh_offset in elf sections. Used in V2 to …\nEnable the little-endian byte swap instructions\nEnable the negation instruction\nEnable the BPF_PQR instruction class\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the configuration settings assuming this is a loader …\nGet the function registry\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIterate over all entries\nIterate over all keys\nGet a function by its key\nGet a function by its name\nCalculate memory size\nCalculate memory size\nConstructs a built-in program\nConstructs a loader built-in program\nConstructs a mock loader built-in program\nRegister a symbol with an explicit key\nRegister a symbol with an implicit key\nEnsure that rodata sections don’t exceed their maximum …\nSupport syscalls via pseudo calls (insn.src = 0)\nSwaps the reg and imm operands of the subtraction …\nUnregister a symbol again\nResult of the executable analysis\nA node of the control-flow graph\nThe register or memory location a data-flow edge guards\nAn edge of the data-flow graph\nThe kind of a data-flow edge\nAn instruction or Φ node of the data-flow graph\nThis kind incurrs no actual data-flow\nThis kind represents data-flow edges which actually carry …\nPoints to a single instruction\nA (potentially writeable) memory location\nPoints to a basic block which starts with a Φ node …\nA BPF register\nUsed for topological sort\nRegister state recorded after executing one instruction\nNodes of the control-flow graph\nFinds the dominance hierarchy of the control-flow graph\nFinds the strongly connected components\nThe DfgNode that depends on the source\nSuccessors which the end of this basic block can jump to\nData flow edges (the keys are DfgEdge sources)\nData flow edges (the keys are DfgEdge destinations)\nGenerates assembler code for the analyzed executable\nGenerates assembler code for a single instruction\nGenerates labels for assembler code\nUse this method to print the trace log\nDiscovery order inside a strongly connected component\nAll basic blocks which can only be reached through this one\nImmediate dominator (the last control flow junction)\nCfgNode where the execution starts\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAnalyze an executable statically\nFunctions in the executable\nPlain list of instructions as they occur in the executable\nRange of the instructions belonging to this basic block\nConnect the dependencies inbetween the basic blocks\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConnect the dependencies between the instructions inside …\nIterates over the cfg_nodes while providing the PC range …\nWrite-read or write-write\nHuman readable name\nGives the basic blocks names\nA register or memory location\nStrongly connected component ID\nThe DfgNode that the destination depends on\nPredecessors which can jump to the start of this basic …\nSplits the sequence of instructions into basic blocks\nVirtual CfgNode that reaches all functions\nTopological index\nTopological order of cfg_nodes\nGenerates a graphviz DOT of the analyzed executable\nThe idea is to assemble five bytes into a single <code>u64</code>. For …\nSame as <code>void *memfrob(void *s, size_t n);</code> in <code>string.h</code> in …\nC-like <code>strcmp</code>, return 0 if the strings are equal, and a …\nPrints a NULL-terminated UTF-8 string.\nPrints its <strong>last three</strong> arguments to standard output. The …\nPrints the five arguments formated as u64 in decimal.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRust interface\nRust interface\nRust interface\nRust interface\nRust interface\nRust interface\nVM interface\nVM interface\nVM interface\nVM interface\nVM interface\nVM interface\nCannotWriteR10\nDivision by zero\nIncompleteLDDW\nInfiniteLoop\nInvalidDestinationRegister\nInvalid function\nInvalid register specified\nInvalidSourceRegister\nJumpOutOfCode\nJumpToMiddleOfLDDW\nLDDWCannotBeLast\nNoProgram\nProgramLengthNotMultiple\nDeprecated\nMandatory verifier for solana programs to run on-chain\nShift with overflow\nUnknownOpCode\nUnsupportedLEBEArgument\neBPF Verifier\nError definitions\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\neBPF verification function that returns an error if the …\nCheck the program against the verifier’s rules\nA call frame used for function calls inside the Interpreter\nVM configuration settings\nRuntime context\nStatistic of taken branches (from a recorded trace)\nA virtual machine to run eBPF programs.\nSimple instruction meter for testing\nUse aligned memory mapping\nThe current call depth.\nStack of CallFrames used by the Interpreter\nThe caller saved registers\nCompares an interpreter trace and a JIT trace.\nConsume instructions from meter\nPointer to ContextObject\nOutstanding value to instruction_meter.consume()\nMaximal edge counter value\nsrc_node, dst_node, edge_counter\nEnables the use of MemoryMapping and MemoryRegion for …\nEnable instruction meter and limiting\nEnable instruction tracing\nAllow ExecutableCapability::V1\nAllow ExecutableCapability::V2\nEnables gaps in VM address space between the stack frames\nEnable dynamic string allocation for labels\nExecute the program\nThrow ElfError::SymbolHashCollision when a BPF function …\nThe callers frame pointer\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the number of remaining instructions allowed\nReturns (and if not done before generates) the encryption …\nNeeded to exit from the guest back into the host\nMaximal pc distance after which a new instruction meter …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInvokes a built-in function\nLoader built-in program\nMaximum call depth\nMemoryMapping inlined\nAccumulates a trace\nCreates a new virtual machine instance.\nInitialize with instruction meter\nUse the new ELF parser\nRatio of native host instructions per random no-op in JIT …\nAvoid copying read only sections when possible\nLast return value of instruction_meter.get_remaining()\nProgramResult inlined\nRegisters inlined\nReject ELF files containing issues that the verifier did …\nHave the verifier reject “callx r10”\nMaximal amount of instructions which still can be executed\nEnable disinfection of immediate values and offsets …\nSize of a stack frame in bytes, must match the size …\nGuest stack pointer (r11).\nReturns the size of the stack memory region\nNumber of times the stop watch was used\nCPU cycles accumulated by the stop watch\nThe target_pc of the exit instruction which returns back …\nCalled for every instruction executed when tracing is …\nContains the register state at every instruction in order …")